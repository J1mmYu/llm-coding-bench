{"task_id": "COBOL/0001", "language": "COBOL", "difficulty": "easy", "instruction": "Read n and print the sum of 1..n.", "prompt": "Sum 1..n.", "mode": "io", "canonical_solution": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SUMN.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 N        PIC S9(18) COMP-5.\n       01 S        PIC S9(18) COMP-5.\n       01 OUTSTR   PIC Z(18)9.\n       PROCEDURE DIVISION.\n           ACCEPT N\n           COMPUTE S = (N * (N + 1)) / 2\n           MOVE S TO OUTSTR\n           DISPLAY FUNCTION TRIM(OUTSTR)\n           GOBACK.\n       END PROGRAM SUMN.\n", "tests": [{"input": "1\n", "output": "1"}, {"input": "10\n", "output": "55"}]}
{"task_id": "COBOL/0002", "language": "COBOL", "difficulty": "easy", "instruction": "Read a line and print it reversed.", "prompt": "Reverse a line.", "mode": "io", "canonical_solution": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. REVERSE.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 S        PIC X(1000).\n       01 I        PIC S9(9) COMP-5.\n       01 L        PIC S9(9) COMP-5.\n       PROCEDURE DIVISION.\n           ACCEPT S\n           MOVE FUNCTION LENGTH(FUNCTION TRIM(S)) TO L\n           PERFORM VARYING I FROM L BY -1 UNTIL I < 1\n              DISPLAY S(I:1) WITH NO ADVANCING\n           END-PERFORM\n           DISPLAY \"\"\n           GOBACK.\n       END PROGRAM REVERSE.\n", "tests": [{"input": "abc\n", "output": "cba"}]}
{"task_id": "COBOL/0003", "language": "COBOL", "difficulty": "hard", "instruction": "Given n (1<=n<=2e5) and an array of n integers, print the length of the longest subarray with sum=0.", "prompt": "Given n (1<=n<=2e5) and an array of n integers, print the length of the longest subarray with sum=0.", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. LONGEST-ZERO-SUBARRAY.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 N PIC 9(6).\n01 I PIC 9(6).\n01 J PIC 9(6).\n01 ARRAY-VALS.\n   05 ARR-ELEM PIC S9(10) OCCURS 200000 TIMES.\n01 PREFIX-SUM PIC S9(18).\n01 MAP-TABLE.\n   05 MAP-ENTRY OCCURS 400002 TIMES.\n      10 MAP-KEY PIC S9(18).\n      10 MAP-VAL PIC 9(6).\n      10 MAP-USED PIC 9.\n01 HASH-IDX PIC 9(6).\n01 TEMP-SUM PIC S9(18).\n01 MAX-LEN PIC 9(6) VALUE 0.\n01 CURR-LEN PIC 9(6).\n01 HASH-BASE PIC 9(18) VALUE 1000000000000000000.\n01 TEMP-CALC PIC 9(18).\n01 INPUT-LINE PIC X(2000000).\n01 LINE-POS PIC 9(7).\n01 LINE-LEN PIC 9(7).\n01 CHAR-VAL PIC X.\n01 NUM-VAL PIC S9(10).\n01 NUM-SIGN PIC S9.\n01 IN-NUMBER PIC 9.\n\nPROCEDURE DIVISION.\n    ACCEPT N.\n    ACCEPT INPUT-LINE.\n    \n    MOVE 1 TO LINE-POS.\n    MOVE FUNCTION LENGTH(FUNCTION TRIM(INPUT-LINE)) TO LINE-LEN.\n    \n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > N\n        MOVE 0 TO NUM-VAL\n        MOVE 1 TO NUM-SIGN\n        MOVE 0 TO IN-NUMBER\n        \n        PERFORM UNTIL LINE-POS > LINE-LEN\n            MOVE INPUT-LINE(LINE-POS:1) TO CHAR-VAL\n            IF CHAR-VAL = ' ' OR CHAR-VAL = X'09'\n                IF IN-NUMBER = 1\n                    EXIT PERFORM\n                END-IF\n            ELSE IF CHAR-VAL = '-'\n                MOVE -1 TO NUM-SIGN\n                MOVE 1 TO IN-NUMBER\n            ELSE\n                COMPUTE NUM-VAL = NUM-VAL * 10 + \n                    (FUNCTION ORD(CHAR-VAL) - FUNCTION ORD('0'))\n                MOVE 1 TO IN-NUMBER\n            END-IF\n            ADD 1 TO LINE-POS\n        END-PERFORM\n        \n        COMPUTE ARR-ELEM(I) = NUM-VAL * NUM-SIGN\n    END-PERFORM.\n    \n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > 400002\n        MOVE 0 TO MAP-USED(I)\n    END-PERFORM.\n    \n    MOVE 0 TO MAP-KEY(200001).\n    MOVE 0 TO MAP-VAL(200001).\n    MOVE 1 TO MAP-USED(200001).\n    \n    MOVE 0 TO PREFIX-SUM.\n    \n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > N\n        ADD ARR-ELEM(I) TO PREFIX-SUM\n        \n        ADD PREFIX-SUM TO HASH-BASE GIVING TEMP-CALC\n        DIVIDE TEMP-CALC BY 400001 GIVING J REMAINDER HASH-IDX\n        ADD 1 TO HASH-IDX\n        \n        PERFORM UNTIL HASH-IDX > 400002\n            IF MAP-USED(HASH-IDX) = 0\n                MOVE PREFIX-SUM TO MAP-KEY(HASH-IDX)\n                MOVE I TO MAP-VAL(HASH-IDX)\n                MOVE 1 TO MAP-USED(HASH-IDX)\n                EXIT PERFORM\n            ELSE IF MAP-KEY(HASH-IDX) = PREFIX-SUM\n                COMPUTE CURR-LEN = I - MAP-VAL(HASH-IDX)\n                IF CURR-LEN > MAX-LEN\n                    MOVE CURR-LEN TO MAX-LEN\n                END-IF\n                EXIT PERFORM\n            END-IF\n            \n            ADD 1 TO HASH-IDX\n            IF HASH-IDX > 400002\n                MOVE 1 TO HASH-IDX\n            END-IF\n        END-PERFORM\n    END-PERFORM.\n    \n    DISPLAY MAX-LEN.\n    STOP RUN.\n", "tests": [{"input": "1\n0", "output": "1"}, {"input": "1\n5", "output": "0"}, {"input": "5\n2 -2 3 -3 4", "output": "4"}, {"input": "6\n1 2 -3 3 -1 -2", "output": "6"}, {"input": "7\n1 -1 1 -1 1 -1 1", "output": "6"}, {"input": "8\n4 -1 -3 1 2 -1 -2 2", "output": "7"}, {"input": "5\n0 0 0 0 0", "output": "5"}, {"input": "5\n1 2 3 4 5", "output": "0"}, {"input": "4\n0 1 -1 0", "output": "4"}, {"input": "2\n1000000000 -1000000000", "output": "2"}], "raw_generation": []}
{"task_id": "COBOL/0004", "language": "COBOL", "difficulty": "hard", "instruction": "Read a line and check balanced brackets for ()[]{} with nesting; print YES/NO.", "prompt": "Read a line and check balanced brackets for ()[]{} with nesting; print YES/NO.", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. BRACKET-CHECKER.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  INPUT-LINE          PIC X(1000).\n01  LINE-LENGTH         PIC 9(4) COMP.\n01  STACK-AREA          PIC X(1000).\n01  STACK-PTR           PIC 9(4) COMP VALUE 0.\n01  IDX                 PIC 9(4) COMP.\n01  CURRENT-CHAR        PIC X.\n01  TOP-CHAR            PIC X.\n01  VALID-FLAG          PIC 9 VALUE 1.\n\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\n    ACCEPT INPUT-LINE.\n    MOVE FUNCTION LENGTH(FUNCTION TRIM(INPUT-LINE)) \n         TO LINE-LENGTH.\n    \n    PERFORM VARYING IDX FROM 1 BY 1 UNTIL IDX > LINE-LENGTH\n        OR VALID-FLAG = 0\n        MOVE INPUT-LINE(IDX:1) TO CURRENT-CHAR\n        \n        EVALUATE CURRENT-CHAR\n            WHEN '('\n            WHEN '['\n            WHEN '{'\n                PERFORM PUSH-STACK\n            WHEN ')'\n                PERFORM POP-AND-CHECK-MATCH\n                IF TOP-CHAR NOT = '('\n                    MOVE 0 TO VALID-FLAG\n                END-IF\n            WHEN ']'\n                PERFORM POP-AND-CHECK-MATCH\n                IF TOP-CHAR NOT = '['\n                    MOVE 0 TO VALID-FLAG\n                END-IF\n            WHEN '}'\n                PERFORM POP-AND-CHECK-MATCH\n                IF TOP-CHAR NOT = '{'\n                    MOVE 0 TO VALID-FLAG\n                END-IF\n        END-EVALUATE\n    END-PERFORM.\n    \n    IF VALID-FLAG = 1 AND STACK-PTR = 0\n        DISPLAY 'YES'\n    ELSE\n        DISPLAY 'NO'\n    END-IF\n    \n    STOP RUN.\n\nPUSH-STACK.\n    ADD 1 TO STACK-PTR.\n    MOVE CURRENT-CHAR TO STACK-AREA(STACK-PTR:1).\n\nPOP-AND-CHECK-MATCH.\n    IF STACK-PTR = 0\n        MOVE 0 TO VALID-FLAG\n        MOVE SPACE TO TOP-CHAR\n    ELSE\n        MOVE STACK-AREA(STACK-PTR:1) TO TOP-CHAR\n        SUBTRACT 1 FROM STACK-PTR\n    END-IF.\n", "tests": [{"input": "", "output": "YES"}, {"input": "()", "output": "YES"}, {"input": "([]){}", "output": "YES"}, {"input": "(]", "output": "NO"}, {"input": "([)]", "output": "NO"}, {"input": "(((", "output": "NO"}, {"input": "())", "output": "NO"}, {"input": "a[b(c){d}e]f", "output": "YES"}, {"input": "]", "output": "NO"}, {"input": " [ { ( ) } ] ", "output": "YES"}, {"input": "No brackets here!", "output": "YES"}, {"input": "({}[]){[()()]}", "output": "YES"}, {"input": "([{}])][", "output": "NO"}, {"input": "{[}]", "output": "NO"}], "raw_generation": []}
{"task_id": "COBOL/0005", "language": "COBOL", "difficulty": "hard", "instruction": "Read n and n integers; print the length of the longest increasing subsequence (not necessarily contiguous).", "prompt": "Read n and n integers; print the length of the longest increasing subsequence (not necessarily contiguous).", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. LIS.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 N PIC 9(4).\n01 I PIC 9(4).\n01 J PIC 9(4).\n01 MAX-LEN PIC 9(4).\n01 ARR OCCURS 1000 TIMES PIC S9(9).\n01 DP OCCURS 1000 TIMES PIC 9(4).\n01 INPUT-VAL PIC S9(9).\nPROCEDURE DIVISION.\nACCEPT N.\nPERFORM VARYING I FROM 1 BY 1 UNTIL I > N\n    ACCEPT ARR(I)\nEND-PERFORM.\nPERFORM VARYING I FROM 1 BY 1 UNTIL I > N\n    MOVE 1 TO DP(I)\nEND-PERFORM.\nPERFORM VARYING I FROM 2 BY 1 UNTIL I > N\n    PERFORM VARYING J FROM 1 BY 1 UNTIL J >= I\n        IF ARR(J) < ARR(I)\n            IF DP(J) + 1 > DP(I)\n                COMPUTE DP(I) = DP(J) + 1\n            END-IF\n        END-IF\n    END-PERFORM\nEND-PERFORM.\nMOVE 0 TO MAX-LEN.\nPERFORM VARYING I FROM 1 BY 1 UNTIL I > N\n    IF DP(I) > MAX-LEN\n        MOVE DP(I) TO MAX-LEN\n    END-IF\nEND-PERFORM.\nDISPLAY MAX-LEN.\nSTOP RUN.\n", "tests": [{"input": "5\n1 2 3 4 5\n", "output": "5\n"}, {"input": "6\n10 9 8 7 6 5\n", "output": "1\n"}, {"input": "8\n2 2 2 2 2 2 2 2\n", "output": "1\n"}, {"input": "7\n3 4 -1 0 6 2 3\n", "output": "4\n"}, {"input": "10\n-5 -1 -1 -2 0 1 -3 2 2 3\n", "output": "6\n"}, {"input": "0\n", "output": "0\n"}, {"input": "12\n1 2 2 3 1 2 3 4 0 5 6 7\n", "output": "7\n"}, {"input": "9\n9 1 3 7 5 6 20 4 8\n", "output": "5\n"}, {"input": "7\n0 0 0 0 1 0 2\n", "output": "3\n"}, {"input": "1\n42\n", "output": "1\n"}], "raw_generation": []}
{"task_id": "COBOL/0006", "language": "COBOL", "difficulty": "hard", "instruction": "Read a CSV line with quotes and commas; parse fields and print field count. Quotes may contain commas and escaped quotes \"\".", "prompt": "Read a CSV line with quotes and commas; parse fields and print field count. Quotes may contain commas and escaped quotes \"\".", "mode": "io", "canonical_solution": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSVPARSER.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  CSV-LINE            PIC X(1000).\n       01  LINE-LENGTH         PIC 9999 VALUE 0.\n       01  CURRENT-POS         PIC 9999 VALUE 1.\n       01  FIELD-COUNT         PIC 9999 VALUE 0.\n       01  IN-QUOTES           PIC 9 VALUE 0.\n       01  CURRENT-CHAR        PIC X.\n       01  NEXT-CHAR           PIC X.\n       01  FIELD-COUNT-DISP    PIC Z(4).\n       \n       PROCEDURE DIVISION.\n           ACCEPT CSV-LINE.\n           \n           INSPECT CSV-LINE TALLYING LINE-LENGTH \n               FOR CHARACTERS BEFORE INITIAL X'00'.\n           \n           IF LINE-LENGTH = 0\n               INSPECT CSV-LINE TALLYING LINE-LENGTH\n                   FOR CHARACTERS\n           END-IF.\n           \n           MOVE 1 TO FIELD-COUNT.\n           MOVE 0 TO IN-QUOTES.\n           MOVE 1 TO CURRENT-POS.\n           \n           PERFORM UNTIL CURRENT-POS > LINE-LENGTH\n               MOVE CSV-LINE(CURRENT-POS:1) TO CURRENT-CHAR\n               \n               IF CURRENT-CHAR = '\"'\n                   IF CURRENT-POS < LINE-LENGTH\n                       COMPUTE CURRENT-POS = CURRENT-POS + 1\n                       MOVE CSV-LINE(CURRENT-POS:1) TO NEXT-CHAR\n                       IF NEXT-CHAR = '\"' AND IN-QUOTES = 1\n                           COMPUTE CURRENT-POS = CURRENT-POS + 1\n                       ELSE\n                           COMPUTE CURRENT-POS = CURRENT-POS - 1\n                           IF IN-QUOTES = 0\n                               MOVE 1 TO IN-QUOTES\n                           ELSE\n                               MOVE 0 TO IN-QUOTES\n                           END-IF\n                           COMPUTE CURRENT-POS = CURRENT-POS + 1\n                       END-IF\n                   ELSE\n                       IF IN-QUOTES = 0\n                           MOVE 1 TO IN-QUOTES\n                       ELSE\n                           MOVE 0 TO IN-QUOTES\n                       END-IF\n                       COMPUTE CURRENT-POS = CURRENT-POS + 1\n                   END-IF\n               ELSE IF CURRENT-CHAR = ',' AND IN-QUOTES = 0\n                   ADD 1 TO FIELD-COUNT\n                   COMPUTE CURRENT-POS = CURRENT-POS + 1\n               ELSE\n                   COMPUTE CURRENT-POS = CURRENT-POS + 1\n               END-IF\n               END-IF\n           END-PERFORM.\n           \n           MOVE FIELD-COUNT TO FIELD-COUNT-DISP.\n           DISPLAY FIELD-COUNT-DISP.\n           \n           STOP RUN.\n", "tests": [{"input": "a,b,c", "output": "3"}, {"input": "a,\"b,c\",d", "output": "3"}, {"input": "\"He said \"\"Hello\"\"\",World", "output": "2"}, {"input": "a,,c,,", "output": "5"}, {"input": "\"\",\"\",\"\",\"\"", "output": "4"}, {"input": ",,,", "output": "4"}, {"input": ",start,,\"mid,comma\",\"end\"\"quote\"\",x", "output": "6"}, {"input": "\"a\"\"b\"\"c\",\"\"\"\",\"d,e,f\",\"\"\"\"\"\"", "output": "4"}, {"input": "\"\"", "output": "1"}, {"input": "field", "output": "1"}], "raw_generation": []}
{"task_id": "COBOL/0007", "language": "COBOL", "difficulty": "hard", "instruction": "Read a string s and integer k; print the lexicographically smallest substring of length k.", "prompt": "Read a string s and integer k; print the lexicographically smallest substring of length k.", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. SMALLEST-SUBSTRING.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 S PIC X(100).\n01 K PIC 9(3).\n01 S-LEN PIC 9(3).\n01 I PIC 9(3).\n01 J PIC 9(3).\n01 START-POS PIC 9(3).\n01 MIN-START PIC 9(3).\n01 CURRENT-SUB PIC X(100).\n01 MIN-SUB PIC X(100).\n01 RESULT PIC X(100).\n\nPROCEDURE DIVISION.\n    ACCEPT S.\n    ACCEPT K.\n    \n    MOVE FUNCTION LENGTH(FUNCTION TRIM(S)) TO S-LEN.\n    \n    MOVE 1 TO MIN-START.\n    MOVE S(1:K) TO MIN-SUB.\n    \n    PERFORM VARYING I FROM 2 BY 1 UNTIL I > S-LEN - K + 1\n        MOVE S(I:K) TO CURRENT-SUB\n        IF CURRENT-SUB < MIN-SUB\n            MOVE CURRENT-SUB TO MIN-SUB\n            MOVE I TO MIN-START\n        END-IF\n    END-PERFORM.\n    \n    DISPLAY MIN-SUB.\n    \n    STOP RUN.\n", "tests": [{"input": "baca\n2", "output": "ac"}, {"input": "zxyza\n1", "output": "a"}, {"input": "banana\n6", "output": "banana"}, {"input": "aaab\n2", "output": "aa"}, {"input": "abracadabra\n3", "output": "abr"}, {"input": "zzzaaazz\n2", "output": "aa"}, {"input": "cba\n2", "output": "ba"}, {"input": "abcabc\n3", "output": "abc"}, {"input": "bcaaad\n3", "output": "aaa"}], "raw_generation": []}
{"task_id": "COBOL/0008", "language": "COBOL", "difficulty": "hard", "instruction": "Read n and then n intervals [l,r]; merge and output total covered length.", "prompt": "Read n and then n intervals [l,r]; merge and output total covered length.", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. MERGE-INTERVALS.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  N                   PIC 9(5).\n01  I                   PIC 9(5).\n01  J                   PIC 9(5).\n01  INTERVALS.\n    05  INTERVAL OCCURS 1000 TIMES.\n        10  L-VAL       PIC S9(9).\n        10  R-VAL       PIC S9(9).\n01  TEMP-L              PIC S9(9).\n01  TEMP-R              PIC S9(9).\n01  CURRENT-START       PIC S9(9).\n01  CURRENT-END         PIC S9(9).\n01  TOTAL-LENGTH        PIC S9(10) VALUE 0.\n01  OUTPUT-STR          PIC -(10)9.\n\nPROCEDURE DIVISION.\n    ACCEPT N.\n    \n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > N\n        ACCEPT L-VAL(I)\n        ACCEPT R-VAL(I)\n    END-PERFORM.\n    \n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > N - 1\n        PERFORM VARYING J FROM I BY 1 UNTIL J > N\n            IF L-VAL(I) > L-VAL(J) OR \n               (L-VAL(I) = L-VAL(J) AND R-VAL(I) > R-VAL(J))\n                MOVE L-VAL(I) TO TEMP-L\n                MOVE R-VAL(I) TO TEMP-R\n                MOVE L-VAL(J) TO L-VAL(I)\n                MOVE R-VAL(J) TO R-VAL(I)\n                MOVE TEMP-L TO L-VAL(J)\n                MOVE TEMP-R TO R-VAL(J)\n            END-IF\n        END-PERFORM\n    END-PERFORM.\n    \n    IF N > 0\n        MOVE L-VAL(1) TO CURRENT-START\n        MOVE R-VAL(1) TO CURRENT-END\n        PERFORM VARYING I FROM 2 BY 1 UNTIL I > N\n            IF L-VAL(I) <= CURRENT-END\n                IF R-VAL(I) > CURRENT-END\n                    MOVE R-VAL(I) TO CURRENT-END\n                END-IF\n            ELSE\n                ADD CURRENT-END TO TOTAL-LENGTH\n                SUBTRACT CURRENT-START FROM TOTAL-LENGTH\n                MOVE L-VAL(I) TO CURRENT-START\n                MOVE R-VAL(I) TO CURRENT-END\n            END-IF\n        END-PERFORM\n        ADD CURRENT-END TO TOTAL-LENGTH\n        SUBTRACT CURRENT-START FROM TOTAL-LENGTH\n    END-IF.\n    \n    MOVE TOTAL-LENGTH TO OUTPUT-STR.\n    DISPLAY FUNCTION TRIM(OUTPUT-STR).\n    \n    STOP RUN.\n", "tests": [{"input": "3\n7 10\n1 2\n4 6", "output": "6"}, {"input": "4\n1 5\n2 6\n8 10\n9 12", "output": "9"}, {"input": "4\n1 2\n2 4\n5 5\n4 5", "output": "4"}, {"input": "5\n0 10\n2 3\n4 8\n0 10\n-5 -1", "output": "14"}, {"input": "4\n-1000000000 0\n1 1000000000\n-500 500\n1000000000 1000000000", "output": "2000000000"}, {"input": "6\n-3 -1\n-2 0\n1 2\n2 3\n10 10\n5 7", "output": "7"}, {"input": "1\n42 42", "output": "0"}, {"input": "5\n-1 2\n0 3\n3 5\n5 5\n-2 -1", "output": "7"}, {"input": "0", "output": "0"}], "raw_generation": []}
{"task_id": "COBOL/0009", "language": "COBOL", "difficulty": "hard", "instruction": "Read a string; print 1 if it is a valid IPv4 address, else 0.", "prompt": "Read a string; print 1 if it is a valid IPv4 address, else 0.", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. IPV4VALIDATOR.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  INPUT-STRING        PIC X(100).\n01  STRING-LENGTH       PIC 999.\n01  I                   PIC 999.\n01  J                   PIC 999.\n01  DOT-COUNT           PIC 9 VALUE 0.\n01  SEGMENT-START       PIC 999.\n01  SEGMENT-LENGTH      PIC 999.\n01  SEGMENT-STR         PIC X(10).\n01  SEGMENT-NUM         PIC 9(10).\n01  VALID-FLAG          PIC 9 VALUE 1.\n01  CHAR-VAL            PIC X.\n01  HAS-DIGIT           PIC 9.\n01  LEADING-ZERO        PIC 9.\n\nPROCEDURE DIVISION.\n    ACCEPT INPUT-STRING.\n    \n    INSPECT INPUT-STRING TALLYING STRING-LENGTH \n        FOR CHARACTERS BEFORE INITIAL SPACE.\n    \n    IF STRING-LENGTH = 0\n        MOVE 0 TO VALID-FLAG\n        GO TO PRINT-RESULT.\n    \n    MOVE 1 TO SEGMENT-START.\n    MOVE 0 TO DOT-COUNT.\n    \n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > STRING-LENGTH\n        MOVE INPUT-STRING(I:1) TO CHAR-VAL\n        IF CHAR-VAL = '.'\n            ADD 1 TO DOT-COUNT\n            COMPUTE SEGMENT-LENGTH = I - SEGMENT-START\n            IF SEGMENT-LENGTH < 1 OR SEGMENT-LENGTH > 3\n                MOVE 0 TO VALID-FLAG\n                GO TO PRINT-RESULT\n            END-IF\n            MOVE INPUT-STRING(SEGMENT-START:SEGMENT-LENGTH) \n                TO SEGMENT-STR\n            PERFORM VALIDATE-SEGMENT\n            IF VALID-FLAG = 0\n                GO TO PRINT-RESULT\n            END-IF\n            COMPUTE SEGMENT-START = I + 1\n        ELSE\n            IF CHAR-VAL < '0' OR CHAR-VAL > '9'\n                MOVE 0 TO VALID-FLAG\n                GO TO PRINT-RESULT\n            END-IF\n        END-IF\n    END-PERFORM.\n    \n    IF DOT-COUNT NOT = 3\n        MOVE 0 TO VALID-FLAG\n        GO TO PRINT-RESULT.\n    \n    COMPUTE SEGMENT-LENGTH = STRING-LENGTH - SEGMENT-START + 1.\n    IF SEGMENT-LENGTH < 1 OR SEGMENT-LENGTH > 3\n        MOVE 0 TO VALID-FLAG\n        GO TO PRINT-RESULT.\n    \n    MOVE INPUT-STRING(SEGMENT-START:SEGMENT-LENGTH) TO SEGMENT-STR.\n    PERFORM VALIDATE-SEGMENT.\n    \n    PRINT-RESULT.\n    DISPLAY VALID-FLAG.\n    STOP RUN.\n\nVALIDATE-SEGMENT.\n    MOVE 0 TO HAS-DIGIT.\n    MOVE 0 TO LEADING-ZERO.\n    \n    PERFORM VARYING J FROM 1 BY 1 UNTIL J > SEGMENT-LENGTH\n        IF SEGMENT-STR(J:1) NOT = ' '\n            ADD 1 TO HAS-DIGIT\n            IF J = 1 AND SEGMENT-STR(J:1) = '0' \n                MOVE 1 TO LEADING-ZERO\n            END-IF\n        END-IF\n    END-PERFORM.\n    \n    IF HAS-DIGIT = 0\n        MOVE 0 TO VALID-FLAG\n        EXIT PARAGRAPH.\n    \n    IF LEADING-ZERO = 1 AND SEGMENT-LENGTH > 1\n        MOVE 0 TO VALID-FLAG\n        EXIT PARAGRAPH.\n    \n    MOVE 0 TO SEGMENT-NUM.\n    IF SEGMENT-LENGTH = 1\n        COMPUTE SEGMENT-NUM = FUNCTION NUMVAL(SEGMENT-STR(1:1))\n    ELSE IF SEGMENT-LENGTH = 2\n        COMPUTE SEGMENT-NUM = FUNCTION NUMVAL(SEGMENT-STR(1:2))\n    ELSE IF SEGMENT-LENGTH = 3\n        COMPUTE SEGMENT-NUM = FUNCTION NUMVAL(SEGMENT-STR(1:3))\n    END-IF.\n    \n    IF SEGMENT-NUM > 255\n        MOVE 0 TO VALID-FLAG.\n", "tests": [{"input": "192.168.1.1", "output": "1"}, {"input": "255.255.255.255", "output": "1"}, {"input": "0.0.0.0", "output": "1"}, {"input": "10.0.0.0", "output": "1"}, {"input": "0.10.0.200", "output": "1"}, {"input": "256.100.100.100", "output": "0"}, {"input": "192.168.001.1", "output": "0"}, {"input": "01.2.3.4", "output": "0"}, {"input": "10.0.0.01", "output": "0"}, {"input": "1.2.3", "output": "0"}, {"input": "1.2.3.4.5", "output": "0"}, {"input": "1..3.4", "output": "0"}, {"input": "1.2.3.-4", "output": "0"}, {"input": "1.2.3.a", "output": "0"}, {"input": " 1.2.3.4 ", "output": "0"}, {"input": "1.2.3.4.", "output": "0"}, {"input": "", "output": "0"}], "raw_generation": []}
{"task_id": "COBOL/0010", "language": "COBOL", "difficulty": "hard", "instruction": "Read a line; print word frequencies sorted by (-count, word).", "prompt": "Read a line; print word frequencies sorted by (-count, word).", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. WORDFREQ.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  INPUT-LINE          PIC X(10000).\n01  LINE-LENGTH         PIC 9999 VALUE 0.\n01  IDX                 PIC 9999 VALUE 1.\n01  WORD-START          PIC 9999 VALUE 0.\n01  WORD-END            PIC 9999 VALUE 0.\n01  CURRENT-WORD        PIC X(1000).\n01  WORD-LEN            PIC 9999 VALUE 0.\n01  CHAR-AT-IDX         PIC X.\n\n01  WORD-TABLE.\n    05  WORD-ENTRY OCCURS 1000 TIMES INDEXED BY WI.\n        10  WT-WORD     PIC X(1000).\n        10  WT-COUNT    PIC 9999 VALUE 0.\n        10  WT-ACTIVE   PIC 9 VALUE 0.\n\n01  NUM-WORDS           PIC 9999 VALUE 0.\n01  FOUND-FLAG          PIC 9 VALUE 0.\n01  SEARCH-IDX          PIC 9999.\n\n01  SORT-I              PIC 9999.\n01  SORT-J              PIC 9999.\n01  TEMP-WORD           PIC X(1000).\n01  TEMP-COUNT          PIC 9999.\n\n01  PRINT-LINE          PIC X(1100).\n\nPROCEDURE DIVISION.\n    ACCEPT INPUT-LINE.\n    \n    INSPECT INPUT-LINE TALLYING LINE-LENGTH \n        FOR CHARACTERS BEFORE INITIAL X'00'.\n    \n    IF LINE-LENGTH = 0\n        INSPECT INPUT-LINE TALLYING LINE-LENGTH FOR ALL X'20'\n        ADD 10000 TO ZERO GIVING LINE-LENGTH\n        SUBTRACT LINE-LENGTH FROM 10000 GIVING LINE-LENGTH\n    END-IF.\n    \n    PERFORM VARYING IDX FROM 1 BY 1 UNTIL IDX > LINE-LENGTH\n        MOVE INPUT-LINE(IDX:1) TO CHAR-AT-IDX\n        \n        IF CHAR-AT-IDX NOT = SPACE\n            IF WORD-START = 0\n                MOVE IDX TO WORD-START\n            END-IF\n            MOVE IDX TO WORD-END\n        ELSE\n            IF WORD-START > 0\n                PERFORM ADD-WORD\n                MOVE 0 TO WORD-START\n                MOVE 0 TO WORD-END\n            END-IF\n        END-IF\n    END-PERFORM.\n    \n    IF WORD-START > 0\n        PERFORM ADD-WORD\n    END-IF.\n    \n    PERFORM BUBBLE-SORT.\n    \n    PERFORM VARYING SORT-I FROM 1 BY 1 UNTIL SORT-I > NUM-WORDS\n        IF WT-ACTIVE(SORT-I) = 1\n            STRING WT-WORD(SORT-I) DELIMITED BY '  '\n                   ' ' DELIMITED BY SIZE\n                   WT-COUNT(SORT-I) DELIMITED BY SIZE\n                   INTO PRINT-LINE\n            END-STRING\n            DISPLAY FUNCTION TRIM(PRINT-LINE)\n        END-IF\n    END-PERFORM.\n    \n    STOP RUN.\n\nADD-WORD.\n    COMPUTE WORD-LEN = WORD-END - WORD-START + 1.\n    MOVE INPUT-LINE(WORD-START:WORD-LEN) TO CURRENT-WORD.\n    \n    MOVE 0 TO FOUND-FLAG.\n    PERFORM VARYING SEARCH-IDX FROM 1 BY 1 UNTIL SEARCH-IDX > NUM-WORDS\n        IF WT-WORD(SEARCH-IDX) = CURRENT-WORD\n            ADD 1 TO WT-COUNT(SEARCH-IDX)\n            MOVE 1 TO FOUND-FLAG\n            EXIT PERFORM\n        END-IF\n    END-PERFORM.\n    \n    IF FOUND-FLAG = 0\n        ADD 1 TO NUM-WORDS\n        MOVE CURRENT-WORD TO WT-WORD(NUM-WORDS)\n        MOVE 1 TO WT-COUNT(NUM-WORDS)\n        MOVE 1 TO WT-ACTIVE(NUM-WORDS)\n    END-IF.\n\nBUBBLE-SORT.\n    PERFORM VARYING SORT-I FROM 1 BY 1 UNTIL SORT-I >= NUM-WORDS\n        PERFORM VARYING SORT-J FROM 1 BY 1 \n            UNTIL SORT-J > NUM-WORDS - SORT-I\n            IF WT-COUNT(SORT-J) < WT-COUNT(SORT-J + 1) OR\n               (WT-COUNT(SORT-J) = WT-COUNT(SORT-J + 1) AND\n                WT-WORD(SORT-J) > WT-WORD(SORT-J + 1))\n                MOVE WT-WORD(SORT-J) TO TEMP-WORD\n                MOVE WT-COUNT(SORT-J) TO TEMP-COUNT\n                MOVE WT-WORD(SORT-J + 1) TO WT-WORD(SORT-J)\n                MOVE WT-COUNT(SORT-J + 1) TO WT-COUNT(SORT-J)\n                MOVE TEMP-WORD TO WT-WORD(SORT-J + 1)\n                MOVE TEMP-COUNT TO WT-COUNT(SORT-J + 1)\n            END-IF\n        END-PERFORM\n    END-PERFORM.\n", "tests": [{"input": "apple banana apple orange banana apple", "output": "apple 3\nbanana 2\norange 1"}, {"input": "Apple apple APPLE", "output": "APPLE 1\nApple 1\napple 1"}, {"input": "end. end, end", "output": "end 1\nend, 1\nend. 1"}, {"input": "a\tb  a\t\tb a", "output": "a 3\nb 2"}, {"input": "", "output": ""}, {"input": "2 10 2 10 1 1 1", "output": "1 3\n10 2\n2 2"}, {"input": "   x   y z   ", "output": "x 1\ny 1\nz 1"}, {"input": "hello hello hello hello", "output": "hello 4"}], "raw_generation": []}
{"task_id": "COBOL/0011", "language": "COBOL", "difficulty": "hard", "instruction": "Given n,m and a grid of '.' and '#', count connected components (4-direction).", "prompt": "Given n,m and a grid of '.' and '#', count connected components (4-direction).", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. CONNECTED-COMPONENTS.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  N                   PIC 9(4).\n01  M                   PIC 9(4).\n01  GRID.\n    05  GRID-ROW        OCCURS 1000 TIMES.\n        10  GRID-CELL   PIC X OCCURS 1000 TIMES.\n01  VISITED.\n    05  VISITED-ROW     OCCURS 1000 TIMES.\n        10  VISITED-CELL PIC 9 OCCURS 1000 TIMES.\n01  I                   PIC 9(4).\n01  J                   PIC 9(4).\n01  COUNT               PIC 9(8) VALUE 0.\n01  INPUT-LINE          PIC X(1000).\n01  STACK.\n    05  STACK-SIZE      PIC 9(8) VALUE 0.\n    05  STACK-ENTRY     OCCURS 1000000 TIMES.\n        10  STACK-ROW   PIC 9(4).\n        10  STACK-COL   PIC 9(4).\n01  CURR-ROW            PIC 9(4).\n01  CURR-COL            PIC 9(4).\n01  NEW-ROW             PIC 9(4).\n01  NEW-COL             PIC 9(4).\n01  DIR                 PIC 9.\n01  DR                  PIC S9(2).\n01  DC                  PIC S9(2).\n\nPROCEDURE DIVISION.\n    ACCEPT N.\n    ACCEPT M.\n    \n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > N\n        ACCEPT INPUT-LINE\n        PERFORM VARYING J FROM 1 BY 1 UNTIL J > M\n            MOVE INPUT-LINE(J:1) TO GRID-CELL(I, J)\n            MOVE 0 TO VISITED-CELL(I, J)\n        END-PERFORM\n    END-PERFORM.\n    \n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > N\n        PERFORM VARYING J FROM 1 BY 1 UNTIL J > M\n            IF GRID-CELL(I, J) = '#' AND VISITED-CELL(I, J) = 0\n                ADD 1 TO COUNT\n                PERFORM DFS\n            END-IF\n        END-PERFORM\n    END-PERFORM.\n    \n    DISPLAY COUNT.\n    STOP RUN.\n\nDFS.\n    MOVE 0 TO STACK-SIZE.\n    ADD 1 TO STACK-SIZE.\n    MOVE I TO STACK-ROW(STACK-SIZE).\n    MOVE J TO STACK-COL(STACK-SIZE).\n    MOVE 1 TO VISITED-CELL(I, J).\n    \n    PERFORM UNTIL STACK-SIZE = 0\n        MOVE STACK-ROW(STACK-SIZE) TO CURR-ROW\n        MOVE STACK-COL(STACK-SIZE) TO CURR-COL\n        SUBTRACT 1 FROM STACK-SIZE\n        \n        PERFORM VARYING DIR FROM 1 BY 1 UNTIL DIR > 4\n            EVALUATE DIR\n                WHEN 1 MOVE -1 TO DR MOVE 0 TO DC\n                WHEN 2 MOVE 1 TO DR MOVE 0 TO DC\n                WHEN 3 MOVE 0 TO DR MOVE -1 TO DC\n                WHEN 4 MOVE 0 TO DR MOVE 1 TO DC\n            END-EVALUATE\n            \n            COMPUTE NEW-ROW = CURR-ROW + DR\n            COMPUTE NEW-COL = CURR-COL + DC\n            \n            IF NEW-ROW >= 1 AND NEW-ROW <= N AND\n               NEW-COL >= 1 AND NEW-COL <= M AND\n               GRID-CELL(NEW-ROW, NEW-COL) = '#' AND\n               VISITED-CELL(NEW-ROW, NEW-COL) = 0\n                MOVE 1 TO VISITED-CELL(NEW-ROW, NEW-COL)\n                ADD 1 TO STACK-SIZE\n                MOVE NEW-ROW TO STACK-ROW(STACK-SIZE)\n                MOVE NEW-COL TO STACK-COL(STACK-SIZE)\n            END-IF\n        END-PERFORM\n    END-PERFORM.\n", "tests": [{"input": "1 1\n.\n", "output": "0"}, {"input": "1 1\n#\n", "output": "1"}, {"input": "3 3\n#.#\n.#.\n#.#\n", "output": "5"}, {"input": "3 5\n###..\n.#.#.\n###..\n", "output": "2"}, {"input": "4 4\n#..#\n.##.\n..#.\n#...\n", "output": "4"}, {"input": "2 3\n###\n###\n", "output": "1"}, {"input": "1 5\n#.#.#\n", "output": "3"}, {"input": "5 1\n#\n.\n#\n.\n#\n", "output": "3"}, {"input": "2 2\n..\n..\n", "output": "0"}, {"input": "5 7\n###..##\n#.#..##\n###..#.\n..#..#.\n..###..\n", "output": "2"}], "raw_generation": []}
{"task_id": "COBOL/0012", "language": "COBOL", "difficulty": "hard", "instruction": "Read a line; run-length encode (RLE) it as <char><count> without separators.", "prompt": "Read a line; run-length encode (RLE) it as <char><count> without separators.", "mode": "io", "canonical_solution": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. RLE.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  INPUT-LINE         PIC X(1000).\n       01  INPUT-LENGTH       PIC 9999 VALUE 0.\n       01  I                  PIC 9999 VALUE 1.\n       01  J                  PIC 9999 VALUE 1.\n       01  CURRENT-CHAR       PIC X.\n       01  COUNT              PIC 9999 VALUE 0.\n       01  COUNT-STR          PIC Z(3)9.\n       01  OUTPUT-LINE        PIC X(4000).\n       01  OUTPUT-POS         PIC 9999 VALUE 1.\n       \n       PROCEDURE DIVISION.\n           ACCEPT INPUT-LINE.\n           \n           INSPECT INPUT-LINE TALLYING INPUT-LENGTH \n               FOR CHARACTERS BEFORE INITIAL SPACE.\n           \n           IF INPUT-LENGTH = 0\n               INSPECT INPUT-LINE TALLYING INPUT-LENGTH\n                   FOR ALL X'00' TO X'FF'\n               IF INPUT-LENGTH = 0\n                   MOVE 1000 TO INPUT-LENGTH\n               END-IF\n           END-IF.\n           \n           MOVE INPUT-LINE(1:1) TO CURRENT-CHAR.\n           MOVE 1 TO COUNT.\n           MOVE 2 TO I.\n           \n           PERFORM UNTIL I > INPUT-LENGTH\n               IF INPUT-LINE(I:1) = CURRENT-CHAR\n                   ADD 1 TO COUNT\n               ELSE\n                   MOVE COUNT TO COUNT-STR\n                   STRING CURRENT-CHAR DELIMITED BY SIZE\n                          FUNCTION TRIM(COUNT-STR) DELIMITED BY SIZE\n                          INTO OUTPUT-LINE\n                          WITH POINTER OUTPUT-POS\n                   END-STRING\n                   MOVE INPUT-LINE(I:1) TO CURRENT-CHAR\n                   MOVE 1 TO COUNT\n               END-IF\n               ADD 1 TO I\n           END-PERFORM.\n           \n           MOVE COUNT TO COUNT-STR.\n           STRING CURRENT-CHAR DELIMITED BY SIZE\n                  FUNCTION TRIM(COUNT-STR) DELIMITED BY SIZE\n                  INTO OUTPUT-LINE\n                  WITH POINTER OUTPUT-POS\n           END-STRING.\n           \n           SUBTRACT 1 FROM OUTPUT-POS.\n           DISPLAY OUTPUT-LINE(1:OUTPUT-POS).\n           \n           STOP RUN.\n", "tests": [{"input": "", "output": ""}, {"input": "Z", "output": "Z1"}, {"input": "ABC", "output": "A1B1C1"}, {"input": "AAABCCXXXXXX", "output": "A3B1C2X6"}, {"input": "0001122222333", "output": "03122533"}, {"input": "     ", "output": " 5"}, {"input": "a  bb", "output": "a1 2b2"}, {"input": "!!!??", "output": "!3?2"}, {"input": "AAAAAAAAAAAA", "output": "A12"}, {"input": "Ã¤Ã¤Ã¤Ã¤Î²Î²", "output": "Ã¤4Î²2"}, {"input": "ðŸ˜€ðŸ˜€ðŸ˜ƒ", "output": "ðŸ˜€2ðŸ˜ƒ1"}, {"input": "\\\\\\\\////", "output": "\\4/4"}], "raw_generation": []}
{"task_id": "COBOL/0013", "language": "COBOL", "difficulty": "hard", "instruction": "Read two big integers (up to 10^500) as strings; print their sum.", "prompt": "Read two big integers (up to 10^500) as strings; print their sum.", "mode": "io", "canonical_solution": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. BIGINT-ADD.\n       \n       ENVIRONMENT DIVISION.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  NUM1            PIC X(501).\n       01  NUM2            PIC X(501).\n       01  RESULT          PIC X(502).\n       01  LEN1            PIC 9(4).\n       01  LEN2            PIC 9(4).\n       01  MAXLEN          PIC 9(4).\n       01  I               PIC 9(4).\n       01  J               PIC 9(4).\n       01  K               PIC 9(4).\n       01  CARRY           PIC 9(1) VALUE 0.\n       01  DIGIT1          PIC 9(1).\n       01  DIGIT2          PIC 9(1).\n       01  SUM-DIGIT       PIC 9(2).\n       01  START-POS       PIC 9(4).\n       01  END-FLAG        PIC 9(1) VALUE 0.\n       \n       PROCEDURE DIVISION.\n           ACCEPT NUM1.\n           ACCEPT NUM2.\n           \n           MOVE FUNCTION LENGTH(FUNCTION TRIM(NUM1)) TO LEN1.\n           MOVE FUNCTION LENGTH(FUNCTION TRIM(NUM2)) TO LEN2.\n           \n           IF LEN1 > LEN2\n               MOVE LEN1 TO MAXLEN\n           ELSE\n               MOVE LEN2 TO MAXLEN\n           END-IF.\n           \n           MOVE SPACES TO RESULT.\n           MOVE 0 TO CARRY.\n           \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I > MAXLEN + 1\n               COMPUTE J = LEN1 - I + 1\n               COMPUTE K = LEN2 - I + 1\n               \n               MOVE 0 TO DIGIT1\n               MOVE 0 TO DIGIT2\n               \n               IF J > 0\n                   MOVE NUM1(J:1) TO DIGIT1\n               END-IF\n               \n               IF K > 0\n                   MOVE NUM2(K:1) TO DIGIT2\n               END-IF\n               \n               COMPUTE SUM-DIGIT = DIGIT1 + DIGIT2 + CARRY\n               \n               IF SUM-DIGIT > 9\n                   COMPUTE CARRY = 1\n                   COMPUTE SUM-DIGIT = SUM-DIGIT - 10\n               ELSE\n                   MOVE 0 TO CARRY\n               END-IF\n               \n               COMPUTE J = MAXLEN - I + 2\n               MOVE SUM-DIGIT TO RESULT(J:1)\n           END-PERFORM.\n           \n           MOVE 1 TO START-POS.\n           PERFORM VARYING I FROM 1 BY 1 UNTIL I > MAXLEN + 1\n               IF RESULT(I:1) NOT = '0' AND RESULT(I:1) NOT = ' '\n                   MOVE I TO START-POS\n                   EXIT PERFORM\n               END-IF\n           END-PERFORM.\n           \n           DISPLAY RESULT(START-POS:MAXLEN - START-POS + 2).\n           \n           STOP RUN.\n", "tests": [{"input": "1\n2", "output": "3"}, {"input": "0\n0", "output": "0"}, {"input": "000123\n000077", "output": "200"}, {"input": "999\n1", "output": "1000"}, {"input": "99999999999999999999\n1", "output": "100000000000000000000"}, {"input": "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "output": "20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"input": "123456789123456789123456789\n987654321987654321987654321", "output": "1111111111111111111111111110"}, {"input": "50000000000000000000\n50000000000000000000", "output": "100000000000000000000"}], "raw_generation": []}
{"task_id": "COBOL/0014", "language": "COBOL", "difficulty": "hard", "instruction": "Given n,m and edges (1-indexed), output a topological ordering or print -1 if cycle.", "prompt": "Given n,m and edges (1-indexed), output a topological ordering or print -1 if cycle.", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. TOPOLOGICAL-SORT.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  N                   PIC 9(5).\n01  M                   PIC 9(5).\n01  I                   PIC 9(5).\n01  J                   PIC 9(5).\n01  U                   PIC 9(5).\n01  V                   PIC 9(5).\n01  COUNT               PIC 9(5).\n01  CURRENT             PIC 9(5).\n01  HAS-CYCLE           PIC 9 VALUE 0.\n\n01  IN-DEGREE           OCCURS 100000 TIMES PIC 9(5).\n01  VISITED             OCCURS 100000 TIMES PIC 9.\n01  RESULT              OCCURS 100000 TIMES PIC 9(5).\n\n01  EDGE-TABLE.\n    05  EDGE-FROM       OCCURS 100000 TIMES PIC 9(5).\n    05  EDGE-TO         OCCURS 100000 TIMES PIC 9(5).\n\n01  QUEUE.\n    05  Q-ITEM          OCCURS 100000 TIMES PIC 9(5).\n01  Q-FRONT             PIC 9(5) VALUE 1.\n01  Q-REAR              PIC 9(5) VALUE 0.\n\n01  INPUT-LINE          PIC X(20).\n01  OUTPUT-LINE         PIC X(10).\n\nPROCEDURE DIVISION.\n    ACCEPT INPUT-LINE.\n    UNSTRING INPUT-LINE DELIMITED BY SPACE\n        INTO N M.\n    \n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > N\n        MOVE 0 TO IN-DEGREE(I)\n        MOVE 0 TO VISITED(I)\n    END-PERFORM.\n    \n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > M\n        ACCEPT INPUT-LINE\n        UNSTRING INPUT-LINE DELIMITED BY SPACE\n            INTO U V\n        MOVE U TO EDGE-FROM(I)\n        MOVE V TO EDGE-TO(I)\n        ADD 1 TO IN-DEGREE(V)\n    END-PERFORM.\n    \n    MOVE 0 TO Q-REAR.\n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > N\n        IF IN-DEGREE(I) = 0\n            ADD 1 TO Q-REAR\n            MOVE I TO Q-ITEM(Q-REAR)\n        END-IF\n    END-PERFORM.\n    \n    MOVE 0 TO COUNT.\n    MOVE 1 TO Q-FRONT.\n    \n    PERFORM UNTIL Q-FRONT > Q-REAR\n        MOVE Q-ITEM(Q-FRONT) TO CURRENT\n        ADD 1 TO Q-FRONT\n        ADD 1 TO COUNT\n        MOVE CURRENT TO RESULT(COUNT)\n        \n        PERFORM VARYING I FROM 1 BY 1 UNTIL I > M\n            IF EDGE-FROM(I) = CURRENT\n                SUBTRACT 1 FROM IN-DEGREE(EDGE-TO(I))\n                IF IN-DEGREE(EDGE-TO(I)) = 0\n                    ADD 1 TO Q-REAR\n                    MOVE EDGE-TO(I) TO Q-ITEM(Q-REAR)\n                END-IF\n            END-IF\n        END-PERFORM\n    END-PERFORM.\n    \n    IF COUNT NOT = N\n        DISPLAY \"-1\"\n    ELSE\n        PERFORM VARYING I FROM 1 BY 1 UNTIL I > N\n            MOVE RESULT(I) TO OUTPUT-LINE\n            DISPLAY FUNCTION TRIM(OUTPUT-LINE)\n        END-PERFORM\n    END-IF.\n    \n    STOP RUN.\n", "tests": [{"input": "4 3\n1 2\n2 3\n3 4\n", "output": "1 2 3 4"}, {"input": "3 3\n1 2\n1 3\n2 3\n", "output": "1 2 3"}, {"input": "3 3\n1 2\n2 3\n3 1\n", "output": "-1"}, {"input": "2 1\n2 2\n", "output": "-1"}, {"input": "5 9\n4 1\n1 5\n5 2\n2 3\n4 5\n4 2\n1 2\n1 3\n5 3\n", "output": "4 1 5 2 3"}, {"input": "6 12\n1 4\n4 2\n2 5\n5 3\n3 6\n1 2\n1 5\n4 5\n2 3\n5 6\n1 3\n4 3\n", "output": "1 4 2 5 3 6"}, {"input": "1 0\n", "output": "1"}, {"input": "5 4\n1 2\n2 3\n3 2\n4 5\n", "output": "-1"}], "raw_generation": []}
{"task_id": "COBOL/0015", "language": "COBOL", "difficulty": "hard", "instruction": "Read multiple lines until EOF; output the line with the maximum number of distinct characters (break ties by earliest).", "prompt": "Read multiple lines until EOF; output the line with the maximum number of distinct characters (break ties by earliest).", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. MAX-DISTINCT-CHARS.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  INPUT-LINE          PIC X(1000).\n01  BEST-LINE           PIC X(1000).\n01  CHAR-TABLE          PIC X(256).\n01  BEST-CHAR-TABLE     PIC X(256).\n01  I                   PIC 9999 VALUE 0.\n01  J                   PIC 999 VALUE 0.\n01  DISTINCT-COUNT      PIC 999 VALUE 0.\n01  MAX-DISTINCT        PIC 999 VALUE 0.\n01  CHAR-POS            PIC 999.\n01  CURRENT-CHAR        PIC X.\n01  FOUND-FLAG          PIC 9 VALUE 0.\n01  EOF-FLAG            PIC 9 VALUE 0.\n01  LINE-LENGTH         PIC 9999.\n01  FIRST-LINE-FLAG     PIC 9 VALUE 1.\n\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\n    PERFORM UNTIL EOF-FLAG = 1\n        INITIALIZE INPUT-LINE\n        ACCEPT INPUT-LINE\n            ON EXCEPTION\n                MOVE 1 TO EOF-FLAG\n            NOT ON EXCEPTION\n                PERFORM COUNT-DISTINCT-CHARS\n                IF DISTINCT-COUNT > MAX-DISTINCT OR FIRST-LINE-FLAG = 1\n                    MOVE DISTINCT-COUNT TO MAX-DISTINCT\n                    MOVE INPUT-LINE TO BEST-LINE\n                    MOVE 0 TO FIRST-LINE-FLAG\n                END-IF\n        END-ACCEPT\n    END-PERFORM\n    \n    IF FIRST-LINE-FLAG = 0\n        DISPLAY BEST-LINE\n    END-IF\n    \n    STOP RUN.\n\nCOUNT-DISTINCT-CHARS.\n    MOVE SPACES TO CHAR-TABLE\n    MOVE 0 TO DISTINCT-COUNT\n    MOVE 1 TO I\n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > 1000\n        MOVE INPUT-LINE(I:1) TO CURRENT-CHAR\n        IF CURRENT-CHAR = LOW-VALUE OR CURRENT-CHAR = SPACE AND I > 1 AND INPUT-LINE(I - 1:1) = LOW-VALUE\n            EXIT PERFORM\n        END-IF\n        MOVE 0 TO FOUND-FLAG\n        PERFORM VARYING J FROM 1 BY 1 UNTIL J > 256 OR FOUND-FLAG = 1\n            IF CHAR-TABLE(J:1) = CURRENT-CHAR\n                MOVE 1 TO FOUND-FLAG\n            END-IF\n        END-PERFORM\n        IF FOUND-FLAG = 0\n            ADD 1 TO DISTINCT-COUNT\n            MOVE CURRENT-CHAR TO CHAR-TABLE(DISTINCT-COUNT:1)\n        END-IF\n    END-PERFORM.\n", "tests": [{"input": "hello\nworld\nabcde", "output": "world"}, {"input": "aaaaaa", "output": "aaaaaa"}, {"input": "a a a\na!a!a\nabc def", "output": "abc def"}, {"input": "AaAa\naAaA\nAaBb", "output": "AaBb"}, {"input": " leading\nleading \n lead ing \nlead", "output": " leading"}, {"input": "\nx\nxy\nxyz\nzzzz", "output": "xyz"}, {"input": "12345\n112233\n!@#$%\n!@#$%^\nabcd!@", "output": "!@#$%^"}, {"input": "ab\nba\ncd", "output": "ab"}, {"input": "aa\nbbb\ncccc\nabcde", "output": "abcde"}, {"input": "abc \nab c\nab  c\na bc", "output": "abc "}], "raw_generation": []}
{"task_id": "COBOL/0016", "language": "COBOL", "difficulty": "hard", "instruction": "Read a line; evaluate a simple expression with + - * / and parentheses (integers, no unary minus), print result.", "prompt": "Read a line; evaluate a simple expression with + - * / and parentheses (integers, no unary minus), print result.", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. EXPR-EVAL.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 INPUT-LINE PIC X(256).\n01 INPUT-LEN PIC 9(3) VALUE 0.\n01 POS PIC 9(3) VALUE 1.\n01 RESULT PIC S9(9)V9(6).\n01 DISPLAY-RESULT PIC -(9)9.9(6).\n\n01 STACK-VALS.\n   05 VAL-STACK OCCURS 100 TIMES PIC S9(9)V9(6).\n01 VAL-TOP PIC 9(3) VALUE 0.\n\n01 STACK-OPS.\n   05 OP-STACK OCCURS 100 TIMES PIC X.\n01 OP-TOP PIC 9(3) VALUE 0.\n\n01 CURRENT-CHAR PIC X.\n01 CURRENT-NUM PIC S9(9)V9(6).\n01 NUM-STR PIC X(20).\n01 NUM-LEN PIC 9(2) VALUE 0.\n01 OP1 PIC S9(9)V9(6).\n01 OP2 PIC S9(9)V9(6).\n01 OP-CHAR PIC X.\n01 TEMP-RESULT PIC S9(9)V9(6).\n01 I PIC 9(3).\n\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\n    ACCEPT INPUT-LINE.\n    INSPECT INPUT-LINE TALLYING INPUT-LEN \n        FOR CHARACTERS BEFORE INITIAL SPACE.\n    IF INPUT-LEN = 0\n        MOVE 256 TO INPUT-LEN\n        INSPECT INPUT-LINE REPLACING ALL X'00' BY SPACE\n        INSPECT INPUT-LINE TALLYING INPUT-LEN \n            FOR CHARACTERS BEFORE INITIAL SPACE\n    END-IF.\n    \n    MOVE 1 TO POS.\n    MOVE 0 TO VAL-TOP.\n    MOVE 0 TO OP-TOP.\n    \n    PERFORM PARSE-EXPR.\n    \n    MOVE VAL-STACK(VAL-TOP) TO DISPLAY-RESULT.\n    DISPLAY DISPLAY-RESULT.\n    STOP RUN.\n\nPARSE-EXPR.\n    PERFORM UNTIL POS > INPUT-LEN\n        MOVE INPUT-LINE(POS:1) TO CURRENT-CHAR\n        EVALUATE TRUE\n            WHEN CURRENT-CHAR = ' '\n                ADD 1 TO POS\n            WHEN CURRENT-CHAR >= '0' AND CURRENT-CHAR <= '9'\n                PERFORM READ-NUMBER\n                ADD 1 TO VAL-TOP\n                MOVE CURRENT-NUM TO VAL-STACK(VAL-TOP)\n            WHEN CURRENT-CHAR = '('\n                ADD 1 TO OP-TOP\n                MOVE '(' TO OP-STACK(OP-TOP)\n                ADD 1 TO POS\n            WHEN CURRENT-CHAR = ')'\n                PERFORM APPLY-UNTIL-OPEN-PAREN\n                ADD 1 TO POS\n            WHEN CURRENT-CHAR = '+' OR '-' OR '*' OR '/'\n                PERFORM APPLY-HIGHER-PRECEDENCE\n                ADD 1 TO OP-TOP\n                MOVE CURRENT-CHAR TO OP-STACK(OP-TOP)\n                ADD 1 TO POS\n        END-EVALUATE\n    END-PERFORM.\n    \n    PERFORM APPLY-REMAINING-OPS.\n\nREAD-NUMBER.\n    MOVE 0 TO NUM-LEN.\n    MOVE SPACES TO NUM-STR.\n    PERFORM UNTIL POS > INPUT-LEN\n        MOVE INPUT-LINE(POS:1) TO CURRENT-CHAR\n        IF CURRENT-CHAR >= '0' AND CURRENT-CHAR <= '9'\n            ADD 1 TO NUM-LEN\n            MOVE CURRENT-CHAR TO NUM-STR(NUM-LEN:1)\n            ADD 1 TO POS\n        ELSE\n            EXIT PERFORM\n        END-IF\n    END-PERFORM.\n    MOVE FUNCTION NUMVAL(NUM-STR) TO CURRENT-NUM.\n\nAPPLY-HIGHER-PRECEDENCE.\n    PERFORM UNTIL OP-TOP = 0\n        MOVE OP-STACK(OP-TOP) TO OP-CHAR\n        IF OP-CHAR = '('\n            EXIT PERFORM\n        END-IF\n        IF (CURRENT-CHAR = '*' OR CURRENT-CHAR = '/') AND\n           (OP-CHAR = '+' OR OP-CHAR = '-')\n            EXIT PERFORM\n        END-IF\n        PERFORM APPLY-OP\n    END-PERFORM.\n\nAPPLY-UNTIL-OPEN-PAREN.\n    PERFORM UNTIL OP-TOP = 0\n        MOVE OP-STACK(OP-TOP) TO OP-CHAR\n        IF OP-CHAR = '('\n            SUBTRACT 1 FROM OP-TOP\n            EXIT PERFORM\n        END-IF\n        PERFORM APPLY-OP\n    END-PERFORM.\n\nAPPLY-REMAINING-OPS.\n    PERFORM UNTIL OP-TOP = 0\n        PERFORM APPLY-OP\n    END-PERFORM.\n\nAPPLY-OP.\n    MOVE VAL-STACK(VAL-TOP) TO OP2.\n    SUBTRACT 1 FROM VAL-TOP.\n    MOVE VAL-STACK(VAL-TOP) TO OP1.\n    MOVE OP-STACK(OP-TOP) TO OP-CHAR.\n    SUBTRACT 1 FROM OP-TOP.\n    \n    EVALUATE OP-CHAR\n        WHEN '+'\n            ADD OP1 TO OP2 GIVING TEMP-RESULT\n        WHEN '-'\n            SUBTRACT OP2 FROM OP1 GIVING TEMP-RESULT\n        WHEN '*'\n            MULTIPLY OP1 BY OP2 GIVING TEMP-RESULT\n        WHEN '/'\n            DIVIDE OP1 BY OP2 GIVING TEMP-RESULT\n    END-EVALUATE.\n    \n    MOVE TEMP-RESULT TO VAL-STACK(VAL-TOP).\n", "tests": [{"input": "1+2*3", "output": "7"}, {"input": "(1+2)*3", "output": "9"}, {"input": "10-3-2", "output": "5"}, {"input": "100/5/2", "output": "10"}, {"input": "2*(3+(4*5))", "output": "46"}, {"input": "  8/2*(2+1)  ", "output": "12"}, {"input": "12345+67890*2", "output": "148125"}, {"input": "0*123", "output": "0"}, {"input": "3-10", "output": "-7"}, {"input": "54/(3+2*(4-1))", "output": "6"}, {"input": "   (  2 + 3 ) *  4  ", "output": "20"}, {"input": "100- (20+30)* (1+1)", "output": "0"}, {"input": "(42)", "output": "42"}], "raw_generation": []}
{"task_id": "COBOL/0017", "language": "COBOL", "difficulty": "hard", "instruction": "Read string s; print length of the longest substring without repeating characters.", "prompt": "Read string s; print length of the longest substring without repeating characters.", "mode": "io", "canonical_solution": "IDENTIFICATION DIVISION.\nPROGRAM-ID. LONGEST-SUBSTRING.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  INPUT-STRING            PIC X(1000).\n01  STRING-LENGTH           PIC 9(4) COMP.\n01  MAX-LENGTH              PIC 9(4) COMP VALUE 0.\n01  CURRENT-LENGTH          PIC 9(4) COMP VALUE 0.\n01  I                       PIC 9(4) COMP.\n01  J                       PIC 9(4) COMP.\n01  K                       PIC 9(4) COMP.\n01  START-POS               PIC 9(4) COMP.\n01  FOUND-FLAG              PIC 9 VALUE 0.\n01  CURRENT-CHAR            PIC X.\n01  CHECK-CHAR              PIC X.\n\nPROCEDURE DIVISION.\n    ACCEPT INPUT-STRING.\n    \n    MOVE FUNCTION LENGTH(FUNCTION TRIM(INPUT-STRING)) \n        TO STRING-LENGTH.\n    \n    IF STRING-LENGTH = 0\n        DISPLAY 0\n        STOP RUN.\n    \n    PERFORM VARYING I FROM 1 BY 1 UNTIL I > STRING-LENGTH\n        MOVE 0 TO CURRENT-LENGTH\n        MOVE I TO START-POS\n        \n        PERFORM VARYING J FROM I BY 1 UNTIL J > STRING-LENGTH\n            MOVE INPUT-STRING(J:1) TO CURRENT-CHAR\n            MOVE 0 TO FOUND-FLAG\n            \n            PERFORM VARYING K FROM START-POS BY 1 \n                UNTIL K >= J OR FOUND-FLAG = 1\n                MOVE INPUT-STRING(K:1) TO CHECK-CHAR\n                IF CURRENT-CHAR = CHECK-CHAR\n                    MOVE 1 TO FOUND-FLAG\n                END-IF\n            END-PERFORM\n            \n            IF FOUND-FLAG = 1\n                EXIT PERFORM\n            END-IF\n            \n            ADD 1 TO CURRENT-LENGTH\n        END-PERFORM\n        \n        IF CURRENT-LENGTH > MAX-LENGTH\n            MOVE CURRENT-LENGTH TO MAX-LENGTH\n        END-IF\n    END-PERFORM.\n    \n    DISPLAY MAX-LENGTH.\n    STOP RUN.\n", "tests": [{"input": "", "output": "0"}, {"input": "a", "output": "1"}, {"input": "abcabcbb", "output": "3"}, {"input": "bbbbb", "output": "1"}, {"input": "pwwkew", "output": "3"}, {"input": " ", "output": "1"}, {"input": "dvdf", "output": "3"}, {"input": "anviaj", "output": "5"}, {"input": "tmmzuxt", "output": "5"}, {"input": "AaBbCcA", "output": "6"}, {"input": "123451234", "output": "5"}, {"input": "a!b@c#a$b%", "output": "7"}, {"input": "abba", "output": "2"}, {"input": "abc def ghi", "output": "7"}], "raw_generation": []}
