{"task_id": "Octave/0001", "language": "Octave", "difficulty": "easy", "instruction": "Read n, output the sum of 1..n.", "prompt": "Sum 1..n.", "mode": "io", "canonical_solution": "line = fgetl(stdin);\n n = str2num(line); s = n*(n+1)/2; printf('%d\\n', s);\n", "tests": [{"input": "1\n", "output": "1"}, {"input": "10\n", "output": "55"}]}
{"task_id": "Octave/0002", "language": "Octave", "difficulty": "easy", "instruction": "Read a line and print it reversed.", "prompt": "Reverse a line.", "mode": "io", "canonical_solution": "s = fgetl(stdin);\n printf('%s\\n', fliplr(s));\n", "tests": [{"input": "abc\n", "output": "cba"}]}
{"task_id": "Octave/0003", "language": "Octave", "difficulty": "hard", "instruction": "Given n (1<=n<=2e5) and an array of n integers, print the length of the longest subarray with sum=0.", "prompt": "Given n (1<=n<=2e5) and an array of n integers, print the length of the longest subarray with sum=0.", "mode": "io", "canonical_solution": "n = input('');\narr = input('');\n\nprefix_sum = 0;\nmap = containers.Map('KeyType', 'double', 'ValueType', 'double');\nmap(0) = 0;\nmax_len = 0;\n\nfor i = 1:n\n    prefix_sum = prefix_sum + arr(i);\n    \n    if isKey(map, prefix_sum)\n        max_len = max(max_len, i - map(prefix_sum));\n    else\n        map(prefix_sum) = i;\n    end\nend\n\ndisp(max_len);\n", "tests": [{"input": "5\n1 2 -3 3 -3\n", "output": "5\n"}, {"input": "4\n1 2 3 4\n", "output": "0\n"}, {"input": "6\n0 0 0 0 0 0\n", "output": "6\n"}, {"input": "7\n1 -1 2 -2 3 -3 4\n", "output": "6\n"}, {"input": "8\n3 4 -7 1 3 -2 -2 2\n", "output": "7\n"}, {"input": "1\n0\n", "output": "1\n"}, {"input": "5\n-1 1 -1 1 -1\n", "output": "4\n"}, {"input": "10\n2 -2 2 -2 2 -2 2 -2 2 -2\n", "output": "10\n"}, {"input": "9\n1 2 -2 4 -4 5 -5 6 -1\n", "output": "6\n"}, {"input": "4\n1000000000 -1000000000 5 -5\n", "output": "4\n"}], "raw_generation": []}
{"task_id": "Octave/0004", "language": "Octave", "difficulty": "hard", "instruction": "Read a line and check balanced brackets for ()[]{} with nesting; print YES/NO.", "prompt": "Read a line and check balanced brackets for ()[]{} with nesting; print YES/NO.", "mode": "io", "canonical_solution": "line = input('', 's');\nstack = {};\nbalanced = true;\npairs = containers.Map({')', ']', '}'}, {'(', '[', '{'});\n\nfor i = 1:length(line)\n    c = line(i);\n    if c == '(' || c == '[' || c == '{'\n        stack{end+1} = c;\n    elseif c == ')' || c == ']' || c == '}'\n        if isempty(stack) || ~strcmp(stack{end}, pairs(c))\n            balanced = false;\n            break;\n        end\n        stack(end) = [];\n    end\nend\n\nif balanced && isempty(stack)\n    printf('YES\\n');\nelse\n    printf('NO\\n');\nend\n", "tests": [{"input": "", "output": "YES"}, {"input": "()", "output": "YES"}, {"input": "([]{})", "output": "YES"}, {"input": "([)]", "output": "NO"}, {"input": "(", "output": "NO"}, {"input": ")", "output": "NO"}, {"input": "{[()()]}", "output": "YES"}, {"input": "{[(])}", "output": "NO"}, {"input": "abc(def)[ghi]{jkl}", "output": "YES"}, {"input": "[{)]}", "output": "NO"}, {"input": "no brackets here", "output": "YES"}, {"input": "(()", "output": "NO"}, {"input": "())", "output": "NO"}, {"input": "()[]{}", "output": "YES"}, {"input": "[ ]", "output": "YES"}, {"input": "([{}])(){}[]", "output": "YES"}, {"input": "][", "output": "NO"}, {"input": "([{}](", "output": "NO"}], "raw_generation": []}
{"task_id": "Octave/0005", "language": "Octave", "difficulty": "hard", "instruction": "Read n and n integers; print the length of the longest increasing subsequence (not necessarily contiguous).", "prompt": "Read n and n integers; print the length of the longest increasing subsequence (not necessarily contiguous).", "mode": "io", "canonical_solution": "n = input('');\narr = input('');\n\ndp = ones(1, n);\n\nfor i = 2:n\n    for j = 1:i-1\n        if arr(j) < arr(i)\n            dp(i) = max(dp(i), dp(j) + 1);\n        endif\n    endfor\nendfor\n\nprintf('%d\\n', max(dp));\n", "tests": [{"input": "5\n1 2 3 4 5\n", "output": "5\n"}, {"input": "5\n5 4 3 2 1\n", "output": "1\n"}, {"input": "6\n2 2 2 2 2 2\n", "output": "1\n"}, {"input": "8\n10 9 2 5 3 7 101 18\n", "output": "4\n"}, {"input": "7\n-1 3 4 -2 2 2 2\n", "output": "3\n"}, {"input": "10\n3 10 2 1 20 4 6 7 8 9\n", "output": "6\n"}, {"input": "1\n42\n", "output": "1\n"}, {"input": "0\n", "output": "0\n"}, {"input": "6\n1 2 2 3 3 4\n", "output": "4\n"}, {"input": "6\n1 2\n3\n4 0 -1\n", "output": "4\n"}], "raw_generation": []}
{"task_id": "Octave/0006", "language": "Octave", "difficulty": "hard", "instruction": "Read a CSV line with quotes and commas; parse fields and print field count. Quotes may contain commas and escaped quotes \"\".", "prompt": "Read a CSV line with quotes and commas; parse fields and print field count. Quotes may contain commas and escaped quotes \"\".", "mode": "io", "canonical_solution": "line = fgets(stdin);\nif line == -1\n    return;\nendif\n\nline = strtrim(line);\nfields = {};\ni = 1;\nn = length(line);\n\nwhile i <= n\n    if line(i) == '\"'\n        % Quoted field\n        field = '';\n        i = i + 1; % Skip opening quote\n        while i <= n\n            if line(i) == '\"'\n                if i < n && line(i+1) == '\"'\n                    % Escaped quote\n                    field = [field '\"'];\n                    i = i + 2;\n                else\n                    % End of quoted field\n                    i = i + 1;\n                    break;\n                endif\n            else\n                field = [field line(i)];\n                i = i + 1;\n            endif\n        endwhile\n        fields{end+1} = field;\n        % Skip comma if present\n        if i <= n && line(i) == ','\n            i = i + 1;\n        endif\n    else\n        % Unquoted field\n        field = '';\n        while i <= n && line(i) != ','\n            field = [field line(i)];\n            i = i + 1;\n        endwhile\n        fields{end+1} = field;\n        % Skip comma\n        if i <= n && line(i) == ','\n            i = i + 1;\n        endif\n    endif\nendwhile\n\nprintf('%d\\n', length(fields));\n", "tests": [{"input": "a,b,c", "output": "3"}, {"input": "\"a,b\",c", "output": "2"}, {"input": "\"a \"\"quote\"\" here\",b", "output": "2"}, {"input": ",,", "output": "3"}, {"input": "\"\",a,\"\"", "output": "3"}, {"input": "\"Smith, John\",\"He said \"\"Hello, World!\"\"\"", "output": "2"}, {"input": "a,,\"\",b", "output": "4"}, {"input": "\"ONE, TWO, THREE\"", "output": "1"}, {"input": "a,b,", "output": "3"}, {"input": "\"\"\"\"", "output": "1"}], "raw_generation": []}
{"task_id": "Octave/0007", "language": "Octave", "difficulty": "hard", "instruction": "Read a string s and integer k; print the lexicographically smallest substring of length k.", "prompt": "Read a string s and integer k; print the lexicographically smallest substring of length k.", "mode": "io", "canonical_solution": "s = input('', 's');\nk = input('');\n\nn = length(s);\nmin_substr = s(1:k);\n\nfor i = 2:(n-k+1)\n    current = s(i:i+k-1);\n    if strcmp(current, min_substr) < 0\n        min_substr = current;\n    endif\nendfor\n\ndisp(min_substr);\n", "tests": [{"input": "banana\n3", "output": "ana"}, {"input": "zxyAAa\n1", "output": "A"}, {"input": "abc\n3", "output": "abc"}, {"input": "bAaa\n2", "output": "Aa"}, {"input": "aaaaa\n2", "output": "aa"}, {"input": "a1b2c3\n2", "output": "1b"}, {"input": "abacaba\n3", "output": "aba"}, {"input": "cabbaged\n4", "output": "abba"}], "raw_generation": []}
{"task_id": "Octave/0008", "language": "Octave", "difficulty": "hard", "instruction": "Read n and then n intervals [l,r]; merge and output total covered length.", "prompt": "Read n and then n intervals [l,r]; merge and output total covered length.", "mode": "io", "canonical_solution": "n = input('');\nintervals = zeros(n, 2);\nfor i = 1:n\n    intervals(i, :) = input('');\nend\n\nif n == 0\n    disp(0);\nelse\n    intervals = sortrows(intervals, 1);\n    \n    merged = [];\n    current_start = intervals(1, 1);\n    current_end = intervals(1, 2);\n    \n    for i = 2:n\n        if intervals(i, 1) <= current_end\n            current_end = max(current_end, intervals(i, 2));\n        else\n            merged = [merged; current_start, current_end];\n            current_start = intervals(i, 1);\n            current_end = intervals(i, 2);\n        end\n    end\n    merged = [merged; current_start, current_end];\n    \n    total_length = sum(merged(:, 2) - merged(:, 1));\n    disp(total_length);\nend\n", "tests": [{"input": "2\n1 3\n5 6\n", "output": "3"}, {"input": "3\n1 4\n2 5\n7 9\n", "output": "6"}, {"input": "3\n0 10\n2 3\n4 5\n", "output": "10"}, {"input": "3\n1 2\n2 3\n3 4\n", "output": "3"}, {"input": "3\n-5 -1\n-3 2\n3 4\n", "output": "8"}, {"input": "3\n1 1\n1 1\n0 2\n", "output": "2"}, {"input": "4\n100 200\n50 150\n300 350\n250 260\n", "output": "210"}, {"input": "2\n0 1000000000\n1000000000 2000000000\n", "output": "2000000000"}, {"input": "5\n0 1\n2 3\n4 5\n6 7\n8 9\n", "output": "5"}, {"input": "5\n1 5\n2 6\n3 7\n8 10\n9 12\n", "output": "10"}, {"input": "0\n", "output": "0"}, {"input": "1\n5 5\n", "output": "0"}], "raw_generation": []}
{"task_id": "Octave/0009", "language": "Octave", "difficulty": "hard", "instruction": "Read a string; print 1 if it is a valid IPv4 address, else 0.", "prompt": "Read a string; print 1 if it is a valid IPv4 address, else 0.", "mode": "io", "canonical_solution": "s = input('', 's');\nparts = strsplit(s, '.');\nvalid = 0;\nif length(parts) == 4\n  valid = 1;\n  for i = 1:4\n    part = parts{i};\n    if isempty(part)\n      valid = 0;\n      break;\n    endif\n    if length(part) > 1 && part(1) == '0'\n      valid = 0;\n      break;\n    endif\n    num = str2num(part);\n    if isempty(num) || num != floor(num) || num < 0 || num > 255\n      valid = 0;\n      break;\n    endif\n    if num2str(num) != part\n      valid = 0;\n      break;\n    endif\n  endfor\nendif\ndisp(valid);\n", "tests": [{"input": "0.0.0.0", "output": "1"}, {"input": "255.255.255.255", "output": "1"}, {"input": "192.168.1.1", "output": "1"}, {"input": "1.2.3.4", "output": "1"}, {"input": "256.100.100.100", "output": "0"}, {"input": "1.2.3", "output": "0"}, {"input": "1.2.3.4.5", "output": "0"}, {"input": "01.2.3.4", "output": "0"}, {"input": "1.2.3.04", "output": "0"}, {"input": "-1.2.3.4", "output": "0"}, {"input": "1..3.4", "output": "0"}, {"input": "a.b.c.d", "output": "0"}, {"input": "0.10.0.0", "output": "1"}, {"input": "10.0.0.01", "output": "0"}, {"input": " 1.2.3.4", "output": "0"}, {"input": "1.2.3.4 ", "output": "0"}, {"input": "", "output": "0"}, {"input": ".", "output": "0"}, {"input": "...", "output": "0"}, {"input": "123.045.067.089", "output": "0"}, {"input": "255.255.255.256", "output": "0"}, {"input": "1.2.3.4a", "output": "0"}], "raw_generation": []}
{"task_id": "Octave/0010", "language": "Octave", "difficulty": "hard", "instruction": "Read a line; print word frequencies sorted by (-count, word).", "prompt": "Read a line; print word frequencies sorted by (-count, word).", "mode": "io", "canonical_solution": "line = input('', 's');\nwords = strsplit(line);\nwords = words(~cellfun(@isempty, words));\n\nif isempty(words)\n    return;\nendif\n\n[unique_words, ~, idx] = unique(words);\ncounts = accumarray(idx, 1);\n\n[sorted_counts, sort_idx] = sort(counts, 'descend');\nsorted_words = unique_words(sort_idx);\n\nfor i = 1:length(sorted_words)\n    if sorted_counts(i) == sorted_counts(end) || (i < length(sorted_words) && sorted_counts(i) ~= sorted_counts(i+1))\n        start_idx = i;\n        end_idx = i;\n        while end_idx < length(sorted_words) && sorted_counts(end_idx+1) == sorted_counts(start_idx)\n            end_idx++;\n        endwhile\n        if start_idx ~= end_idx\n            same_count_words = sorted_words(start_idx:end_idx);\n            same_count_words = sort(same_count_words);\n            for j = 1:length(same_count_words)\n                printf('%s %d\\n', same_count_words{j}, sorted_counts(start_idx));\n            endfor\n            i = end_idx;\n        else\n            printf('%s %d\\n', sorted_words{i}, sorted_counts(i));\n        endif\n    elseif i == length(sorted_words)\n        printf('%s %d\\n', sorted_words{i}, sorted_counts(i));\n    endif\nendfor\n```\n\nWait, let me simplify this:\n\n```octave\nline = input('', 's');\nwords = strsplit(line);\nwords = words(~cellfun(@isempty, words));\n\nif isempty(words)\n    return;\nendif\n\n[unique_words, ~, idx] = unique(words);\ncounts = accumarray(idx, 1);\n\nresult = [num2cell(counts), unique_words'];\nresult = sortrows(result, [1, 2], {'descend', 'ascend'});\n\nfor i = 1:size(result, 1)\n    printf('%s %d\\n', result{i, 2}, result{i, 1});\nendfor\n", "tests": [{"input": "one two two three three three", "output": "three 3\ntwo 2\none 1"}, {"input": "hello", "output": "hello 1"}, {"input": "end. end, end end; end", "output": "end 2\nend, 1\nend. 1\nend; 1"}, {"input": "Apple apple APPLE apple", "output": "apple 2\nAPPLE 1\nApple 1"}, {"input": "a    b\t a\t\tb\tc  ", "output": "a 2\nb 2\nc 1"}, {"input": "", "output": ""}, {"input": "beta alpha gamma delta", "output": "alpha 1\nbeta 1\ndelta 1\ngamma 1"}, {"input": "2 10 2 10 1", "output": "10 2\n2 2\n1 1"}], "raw_generation": []}
{"task_id": "Octave/0011", "language": "Octave", "difficulty": "hard", "instruction": "Given n,m and a grid of '.' and '#', count connected components (4-direction).", "prompt": "Given n,m and a grid of '.' and '#', count connected components (4-direction).", "mode": "io", "canonical_solution": "[n m] = scanf(\"%d %d\", \"C\");\ngrid = cell(n, 1);\nfor i = 1:n\n    grid{i} = strtrim(fgets(stdin));\nend\n\nvisited = false(n, m);\ncount = 0;\n\nfunction dfs(i, j, grid, visited, n, m)\n    if i < 1 || i > n || j < 1 || j > m || visited(i, j) || grid{i}(j) == '#'\n        return;\n    end\n    visited(i, j) = true;\n    dfs(i+1, j, grid, visited, n, m);\n    dfs(i-1, j, grid, visited, n, m);\n    dfs(i, j+1, grid, visited, n, m);\n    dfs(i, j-1, grid, visited, n, m);\nend\n\nfor i = 1:n\n    for j = 1:m\n        if !visited(i, j) && grid{i}(j) == '.'\n            stack = [i j];\n            visited(i, j) = true;\n            while size(stack, 1) > 0\n                ci = stack(end, 1);\n                cj = stack(end, 2);\n                stack(end, :) = [];\n                \n                dirs = [1 0; -1 0; 0 1; 0 -1];\n                for d = 1:4\n                    ni = ci + dirs(d, 1);\n                    nj = cj + dirs(d, 2);\n                    if ni >= 1 && ni <= n && nj >= 1 && nj <= m && !visited(ni, nj) && grid{ni}(nj) == '.'\n                        visited(ni, nj) = true;\n                        stack = [stack; ni nj];\n                    end\n                end\n            end\n            count++;\n        end\n    end\nend\n\nprintf(\"%d\\n\", count);\n", "tests": [{"input": "1 1\n.\n", "output": "0"}, {"input": "1 1\n#\n", "output": "1"}, {"input": "3 3\n#.#\n...\n#.#\n", "output": "4"}, {"input": "3 3\n.#.\n###\n.#.\n", "output": "1"}, {"input": "4 5\n##..#\n#..##\n..#..\n#..##\n", "output": "5"}, {"input": "2 4\n####\n####\n", "output": "1"}, {"input": "3 5\n.....\n.....\n.....\n", "output": "0"}, {"input": "5 5\n#...#\n.###.\n.#.#.\n.###.\n#...#\n", "output": "5"}, {"input": "4 4\n#..#\n.##.\n.##.\n#..#\n", "output": "5"}, {"input": "1 5\n#.#.#\n", "output": "3"}], "raw_generation": []}
{"task_id": "Octave/0012", "language": "Octave", "difficulty": "hard", "instruction": "Read a line; run-length encode (RLE) it as <char><count> without separators.", "prompt": "Read a line; run-length encode (RLE) it as <char><count> without separators.", "mode": "io", "canonical_solution": "line = input('', 's');\nif isempty(line)\n  return\nendif\n\ni = 1;\nwhile i <= length(line)\n  current = line(i);\n  count = 1;\n  while i + count <= length(line) && line(i + count) == current\n    count++;\n  endwhile\n  printf('%c%d', current, count);\n  i += count;\nendwhile\nprintf('\\n');\n", "tests": [{"input": "", "output": ""}, {"input": "z", "output": "z1"}, {"input": "aaabbccccd", "output": "a3b2c4d1"}, {"input": "abcd", "output": "a1b1c1d1"}, {"input": "1112221", "output": "132311"}, {"input": "!!!??", "output": "!3?2"}, {"input": "    ", "output": " 4"}, {"input": "a  b", "output": "a1 2b1"}, {"input": "AaaA", "output": "A1a2A1"}, {"input": "aaaaaaaaaab", "output": "a10b1"}, {"input": "游游游땎", "output": "游2游땎1"}, {"input": "  a ", "output": " 2a1 1"}, {"input": "\t\t", "output": "\t2"}, {"input": "aa11bbb2", "output": "a212b321"}, {"input": "침침n", "output": "침2n1"}, {"input": "0000000000", "output": "010"}], "raw_generation": []}
{"task_id": "Octave/0013", "language": "Octave", "difficulty": "hard", "instruction": "Read two big integers (up to 10^500) as strings; print their sum.", "prompt": "Read two big integers (up to 10^500) as strings; print their sum.", "mode": "io", "canonical_solution": "a = input('', 's');\nb = input('', 's');\n\n% Remove leading/trailing whitespace\na = strtrim(a);\nb = strtrim(b);\n\n% Handle negative numbers\nsign_a = 1;\nsign_b = 1;\nif a(1) == '-'\n    sign_a = -1;\n    a = a(2:end);\nendif\nif b(1) == '-'\n    sign_b = -1;\n    b = b(2:end);\nendif\n\n% Convert strings to digit arrays (reverse order for easier addition)\ndigits_a = fliplr(a - '0');\ndigits_b = fliplr(b - '0');\n\n% If signs are different, convert to subtraction\nif sign_a ~= sign_b\n    % Compare absolute values\n    len_a = length(digits_a);\n    len_b = length(digits_b);\n    \n    if len_a > len_b || (len_a == len_b && strcmp(a, b) > 0)\n        % |a| > |b|\n        result_sign = sign_a;\n        [longer, shorter] = deal(digits_a, digits_b);\n    elseif len_a < len_b || (len_a == len_b && strcmp(a, b) < 0)\n        % |a| < |b|\n        result_sign = sign_b;\n        [longer, shorter] = deal(digits_b, digits_a);\n    else\n        % |a| == |b|\n        disp('0');\n        return;\n    endif\n    \n    % Subtraction\n    max_len = length(longer);\n    shorter = [shorter, zeros(1, max_len - length(shorter))];\n    result = zeros(1, max_len);\n    borrow = 0;\n    \n    for i = 1:max_len\n        diff = longer(i) - shorter(i) - borrow;\n        if diff < 0\n            diff = diff + 10;\n            borrow = 1;\n        else\n            borrow = 0;\n        endif\n        result(i) = diff;\n    endfor\nelse\n    % Same sign - addition\n    result_sign = sign_a;\n    max_len = max(length(digits_a), length(digits_b));\n    digits_a = [digits_a, zeros(1, max_len - length(digits_a))];\n    digits_b = [digits_b, zeros(1, max_len - length(digits_b))];\n    \n    result = zeros(1, max_len + 1);\n    carry = 0;\n    \n    for i = 1:max_len\n        sum_val = digits_a(i) + digits_b(i) + carry;\n        result(i) = mod(sum_val, 10);\n        carry = floor(sum_val / 10);\n    endfor\n    result(max_len + 1) = carry;\nendif\n\n% Remove leading zeros\nwhile length(result) > 1 && result(end) == 0\n    result = result(1:end-1);\nendwhile\n\n% Convert back to string\nresult_str = char(fliplr(result) + '0');\n\n% Add sign if negative\nif result_sign < 0\n    result_str = ['-', result_str];\nendif\n\ndisp(result_str);\n", "tests": [{"input": "2 3", "output": "5"}, {"input": "0\n0", "output": "0"}, {"input": "0000123\n00000456", "output": "579"}, {"input": "123456789123456789\n987654321", "output": "123456790111111110"}, {"input": "12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\n12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890", "output": "2469135780246913578024691357802469135780246913578024691357802469135780246913578024691357802469135780246913578024691357802469135780246913578024691357802469135780246913578024691357802469135780246913578024691357802469135780246913578024691357802469135780246913578024691357802469135780"}, {"input": "0 1234567890123456789012345678901234567890", "output": "1234567890123456789012345678901234567890"}, {"input": "   42\t\n   58", "output": "100"}, {"input": "999999999999999999999999999999\n1", "output": "1000000000000000000000000000000"}], "raw_generation": []}
{"task_id": "Octave/0014", "language": "Octave", "difficulty": "hard", "instruction": "Given n,m and edges (1-indexed), output a topological ordering or print -1 if cycle.", "prompt": "Given n,m and edges (1-indexed), output a topological ordering or print -1 if cycle.", "mode": "io", "canonical_solution": "function topological_sort()\n    input_data = input('', 's');\n    lines = strsplit(input_data, '\\n');\n    \n    first_line = str2num(lines{1});\n    n = first_line(1);\n    m = first_line(2);\n    \n    adj = cell(n, 1);\n    for i = 1:n\n        adj{i} = [];\n    end\n    \n    indegree = zeros(n, 1);\n    \n    for i = 1:m\n        edge = str2num(lines{i+1});\n        u = edge(1);\n        v = edge(2);\n        adj{u} = [adj{u}, v];\n        indegree(v) = indegree(v) + 1;\n    end\n    \n    queue = [];\n    for i = 1:n\n        if indegree(i) == 0\n            queue = [queue, i];\n        end\n    end\n    \n    result = [];\n    \n    while length(queue) > 0\n        u = queue(1);\n        queue = queue(2:end);\n        result = [result, u];\n        \n        for i = 1:length(adj{u})\n            v = adj{u}(i);\n            indegree(v) = indegree(v) - 1;\n            if indegree(v) == 0\n                queue = [queue, v];\n            end\n        end\n    end\n    \n    if length(result) != n\n        disp(-1);\n    else\n        disp(result);\n    end\nend\n\ntopological_sort()\n", "tests": [{"input": "1 0\n", "output": "1"}, {"input": "4 3\n1 2\n2 3\n3 4\n", "output": "1 2 3 4"}, {"input": "6 15\n1 2\n1 3\n1 4\n1 5\n1 6\n2 3\n2 4\n2 5\n2 6\n3 4\n3 5\n3 6\n4 5\n4 6\n5 6\n", "output": "1 2 3 4 5 6"}, {"input": "3 4\n1 2\n1 2\n2 3\n1 3\n", "output": "1 2 3"}, {"input": "2 2\n1 2\n2 1\n", "output": "-1"}, {"input": "3 2\n1 2\n3 3\n", "output": "-1"}, {"input": "4 4\n1 2\n2 3\n3 1\n3 4\n", "output": "-1"}, {"input": "5 4\n2 1\n3 2\n4 3\n5 4\n", "output": "5 4 3 2 1"}], "raw_generation": []}
{"task_id": "Octave/0015", "language": "Octave", "difficulty": "hard", "instruction": "Read a line; evaluate a simple expression with + - * / and parentheses (integers, no unary minus), print result.", "prompt": "Read a line; evaluate a simple expression with + - * / and parentheses (integers, no unary minus), print result.", "mode": "io", "canonical_solution": "line = input('', 's');\nresult = eval(line);\nfprintf('%.15g\\n', result);\n", "tests": [{"input": "1+2*3", "output": "7"}, {"input": "(1+2)*3", "output": "9"}, {"input": "10/2+3*4", "output": "17"}, {"input": "18/(3*3)", "output": "2"}, {"input": "42-5*8+6/3", "output": "4"}, {"input": "((2+3)*(4+6))/5", "output": "10"}, {"input": "100/(2*5)+7-8* (3-1)", "output": "1"}, {"input": "8/2/2", "output": "2"}, {"input": "7+8/ ( 2 + 2 ) *3", "output": "13"}, {"input": "12345*(6+7)/ ( 3*5 )", "output": "10699"}, {"input": "3-10+2", "output": "-5"}, {"input": "   6*7   ", "output": "42"}], "raw_generation": []}
{"task_id": "Octave/0016", "language": "Octave", "difficulty": "hard", "instruction": "Read string s; print length of the longest substring without repeating characters.", "prompt": "Read string s; print length of the longest substring without repeating characters.", "mode": "io", "canonical_solution": "s = input('', 's');\nn = length(s);\nmaxLen = 0;\n\nfor i = 1:n\n    seen = containers.Map('KeyType', 'char', 'ValueType', 'logical');\n    for j = i:n\n        if isKey(seen, s(j))\n            break;\n        endif\n        seen(s(j)) = true;\n        maxLen = max(maxLen, j - i + 1);\n    endfor\nendfor\n\ndisp(maxLen);\n", "tests": [{"input": "abcabcbb", "output": "3"}, {"input": "bbbbb", "output": "1"}, {"input": "pwwkew", "output": "3"}, {"input": "", "output": "0"}, {"input": "a", "output": "1"}, {"input": "abcdefg", "output": "7"}, {"input": "dv df", "output": "4"}, {"input": "擔먼봏擔먼봏", "output": "2"}, {"input": "aA", "output": "2"}, {"input": "abba", "output": "2"}, {"input": "tmmzuxt", "output": "5"}, {"input": "123451234", "output": "5"}], "raw_generation": []}
{"task_id": "Octave/0017", "language": "Octave", "difficulty": "easy", "instruction": "Read n then n integers. Print the length of the longest strictly increasing contiguous subarray.", "prompt": "Read n then n integers. Print the length of the longest strictly increasing contiguous subarray.", "mode": "io", "canonical_solution": "```octave\nn = input('');\narr = input('');\n\nmax_len = 1;\ncurrent_len = 1;\n\nfor i = 2:n\n    if arr(i) > arr(i-1)\n        current_len = current_len + 1;\n        max_len = max(max_len, current_len);\n    else\n        current_len = 1;\n    endif\nendfor\n\ndisp(max_len);\n```", "tests": [{"input": "5\n1 2 3 4 5\n", "output": "5\n"}, {"input": "5\n5 4 3 2 1\n", "output": "1\n"}, {"input": "7\n1 2 2 3 4 0 1\n", "output": "3\n"}, {"input": "1\n42\n", "output": "1\n"}, {"input": "10\n-3 -2 -1 -1 0 1 1 2 3 4\n", "output": "4\n"}, {"input": "8\n1 3 2 2\n3 4 5 0\n", "output": "4\n"}, {"input": "9\n10 20 10 20 30 40 5 6 7\n", "output": "4\n"}, {"input": "6\n2 2 2 2 2 2\n", "output": "1\n"}], "raw_generation": []}
{"task_id": "Octave/0018", "language": "Octave", "difficulty": "easy", "instruction": "Read n, print the number of set bits in binary representation of n.", "prompt": "Read n, print the number of set bits in binary representation of n.", "mode": "io", "canonical_solution": "```octave\nn = input('');\nfprintf('%d\\n', sum(dec2bin(n) == '1'));\n```", "tests": [{"input": "0", "output": "0"}, {"input": "1", "output": "1"}, {"input": "2", "output": "1"}, {"input": "7", "output": "3"}, {"input": "16", "output": "1"}, {"input": "31", "output": "5"}, {"input": "1023", "output": "10"}, {"input": "1024", "output": "1"}, {"input": "123456789", "output": "16"}, {"input": "4294967295", "output": "32"}], "raw_generation": []}
{"task_id": "Octave/0019", "language": "Octave", "difficulty": "easy", "instruction": "Read a line and print 'YES' if it is a palindrome ignoring non-alphanumerics and case, else 'NO'.", "prompt": "Read a line and print 'YES' if it is a palindrome ignoring non-alphanumerics and case, else 'NO'.", "mode": "io", "canonical_solution": "```octave\nline = input('', 's');\ncleaned = lower(regexprep(line, '[^a-zA-Z0-9]', ''));\nif strcmp(cleaned, fliplr(cleaned))\n    disp('YES');\nelse\n    disp('NO');\nendif\n```", "tests": [{"input": "racecar", "output": "YES"}, {"input": "hello", "output": "NO"}, {"input": "A man, a plan, a canal: Panama!", "output": "YES"}, {"input": "12,321", "output": "YES"}, {"input": "12345", "output": "NO"}, {"input": "Z", "output": "YES"}, {"input": "!!!", "output": "YES"}, {"input": "Never odd or even", "output": "YES"}, {"input": "No 'x' in Nixon", "output": "YES"}, {"input": "0P", "output": "NO"}, {"input": "Was it a car or a cat I saw?", "output": "YES"}, {"input": "abca", "output": "NO"}], "raw_generation": []}
{"task_id": "Octave/0020", "language": "Octave", "difficulty": "easy", "instruction": "Read n,m then m edges (1-indexed). Print the degree of each node on one line separated by spaces.", "prompt": "Read n,m then m edges (1-indexed). Print the degree of each node on one line separated by spaces.", "mode": "io", "canonical_solution": "```octave\nn = input('');\nm = input('');\ndegree = zeros(1, n);\nfor i = 1:m\n    edge = input('');\n    u = edge(1);\n    v = edge(2);\n    degree(u)++;\n    degree(v)++;\nend\nfprintf('%d', degree(1));\nfor i = 2:n\n    fprintf(' %d', degree(i));\nend\nfprintf('\\n');\n```", "tests": [{"input": "3 2\n1 2\n2 3\n", "output": "1 2 1"}, {"input": "5 0\n", "output": "0 0 0 0 0"}, {"input": "5 4\n3 1\n3 2\n3 4\n3 5\n", "output": "1 1 4 1 1"}, {"input": "4 4\n1 2\n2 3\n3 4\n4 1\n", "output": "2 2 2 2"}, {"input": "6 3\n1 2\n2 3\n5 6\n", "output": "1 2 1 0 1 1"}, {"input": "7 6\n1 2\n1 3\n2 4\n2 5\n3 6\n6 7\n", "output": "2 3 2 1 1 2 1"}, {"input": "5 10\n1 2\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n3 5\n4 5\n", "output": "4 4 4 4 4"}, {"input": "8 5\n8 1\n1 5\n2 8\n4 5\n7 3\n", "output": "2 1 1 1 2 0 1 2"}], "raw_generation": []}
{"task_id": "Octave/0021", "language": "Octave", "difficulty": "easy", "instruction": "Read n then n integers. Print the number of distinct values.", "prompt": "Read n then n integers. Print the number of distinct values.", "mode": "io", "canonical_solution": "```octave\nn = input('');\nvalues = [];\nfor i = 1:n\n    values(i) = input('');\nend\nfprintf('%d\\n', length(unique(values)));\n```", "tests": [{"input": "5\n1 2 2 3 3\n", "output": "3"}, {"input": "4\n7\n7\n7\n7\n", "output": "1"}, {"input": "5\n1\t2 3\t4 5\n", "output": "5"}, {"input": "8\n-1 0 -1 0 1 2 -2 2\n", "output": "5"}, {"input": "0\n", "output": "0"}, {"input": "6\n1000000000 999999999 -1000000000 1000000000 -1000000000 0\n", "output": "4"}, {"input": "1\n42\n", "output": "1"}, {"input": "10\n1 2 3 4 5 1 2 3 4 5\n", "output": "5"}, {"input": "7\n0 0 0 -1 -1 -1 0\n", "output": "2"}, {"input": "   3\n10   10\n  20\n", "output": "2"}], "raw_generation": []}
{"task_id": "Octave/0022", "language": "Octave", "difficulty": "easy", "instruction": "Read a line containing integers separated by commas and/or spaces; print their sum.", "prompt": "Read a line containing integers separated by commas and/or spaces; print their sum.", "mode": "io", "canonical_solution": "```octave\nline = input('', 's');\nline = strrep(line, ',', ' ');\nnums = str2num(line);\ndisp(sum(nums));\n```", "tests": [{"input": "1 2 3 4 5", "output": "15"}, {"input": "10,20,30", "output": "60"}, {"input": "7, 8 9,10 11", "output": "45"}, {"input": "-5, 10, -15", "output": "-10"}, {"input": "   3,4  5   ", "output": "12"}, {"input": "1,,2  , ,3", "output": "6"}, {"input": "42", "output": "42"}, {"input": "+1, +2  -3,0", "output": "0"}, {"input": "0,0 0,0", "output": "0"}, {"input": "1000, 2000 3000, -4000", "output": "1000"}], "raw_generation": []}
{"task_id": "Octave/0023", "language": "Octave", "difficulty": "easy", "instruction": "Given n, print the sum of the digits of n.", "prompt": "Given n, print the sum of the digits of n.", "mode": "io", "canonical_solution": "```octave\nn = input('');\nsum_digits = sum(num2str(abs(n)) - '0');\ndisp(sum_digits);\n```", "tests": [{"input": "0", "output": "0"}, {"input": "7", "output": "7"}, {"input": "12345", "output": "15"}, {"input": "0001010", "output": "2"}, {"input": "-909", "output": "18"}, {"input": "987654321012345", "output": "60"}, {"input": "1000000000000000", "output": "1"}, {"input": "999999999999999", "output": "135"}], "raw_generation": []}
{"task_id": "Octave/0024", "language": "Octave", "difficulty": "easy", "instruction": "Read n,m then m edges (1-indexed). Print the degree of each node on one line separated by spaces.", "prompt": "Read n,m then m edges (1-indexed). Print the degree of each node on one line separated by spaces.", "mode": "io", "canonical_solution": "```octave\nn = input('');\nm = input('');\ndeg = zeros(1, n);\nfor i = 1:m\n    edge = input('');\n    u = edge(1);\n    v = edge(2);\n    deg(u) = deg(u) + 1;\n    deg(v) = deg(v) + 1;\nend\nfprintf('%d', deg(1));\nfor i = 2:n\n    fprintf(' %d', deg(i));\nend\nfprintf('\\n');\n```", "tests": [{"input": "1 0\n", "output": "0\n"}, {"input": "2 1\n1 2\n", "output": "1 1\n"}, {"input": "5 2\n2 3\n3 4\n", "output": "0 1 2 1 0\n"}, {"input": "3 4\n1 2\n1 2\n2 3\n1 3\n", "output": "3 3 2\n"}, {"input": "3 3\n1 1\n1 2\n2 2\n", "output": "3 3 0\n"}, {"input": "4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n", "output": "3 3 3 3\n"}, {"input": "6 5\n1 2\n2 3\n4 5\n5 6\n6 4\n", "output": "1 2 1 2 2 2\n"}, {"input": "7 6\n4 1\n4 2\n4 3\n4 5\n4 6\n4 7\n", "output": "1 1 1 6 1 1 1\n"}], "raw_generation": []}
