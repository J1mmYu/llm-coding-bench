{"task_id": "Prolog/0001", "language": "Prolog", "difficulty": "easy", "instruction": "Read n, output the sum of 1..n.", "prompt": "Sum 1..n.", "mode": "io", "canonical_solution": "main :-\n  read_line_to_codes(user_input, Cs), number_codes(N, Cs),\n  S is N*(N+1)//2,\n  format('~d~n', [S]).\n", "tests": [{"input": "1\n", "output": "1"}, {"input": "10\n", "output": "55"}]}
{"task_id": "Prolog/0002", "language": "Prolog", "difficulty": "easy", "instruction": "Read one line and print it reversed.", "prompt": "Reverse a line.", "mode": "io", "canonical_solution": "main :-\n  read_line_to_codes(user_input, Cs), reverse(Cs, Rc),\n  string_codes(S, Rc), format('~w~n', [S]).\n", "tests": [{"input": "abc\n", "output": "cba"}]}
{"task_id": "Prolog/0003", "language": "Prolog", "difficulty": "hard", "instruction": "Given n (1<=n<=2e5) and an array of n integers, print the length of the longest subarray with sum=0.", "prompt": "Given n (1<=n<=2e5) and an array of n integers, print the length of the longest subarray with sum=0.", "mode": "io", "canonical_solution": ":- use_module(library(readutil)).\n\nread_number(N) :-\n    read_line_to_string(user_input, Line),\n    number_string(N, Line).\n\nread_numbers(Numbers) :-\n    read_line_to_string(user_input, Line),\n    split_string(Line, \" \", \" \", Parts),\n    maplist(number_string, Numbers, Parts).\n\nsolve :-\n    read_number(N),\n    read_numbers(Array),\n    find_longest_zero_sum(Array, Length),\n    writeln(Length).\n\nfind_longest_zero_sum(Array, MaxLen) :-\n    prefix_sums(Array, 0, [], PrefixList),\n    reverse(PrefixList, Prefixes),\n    find_max_distance(Prefixes, 0, MaxLen).\n\nprefix_sums([], _, Acc, Acc).\nprefix_sums([H|T], CumSum, Acc, Result) :-\n    NewSum is CumSum + H,\n    prefix_sums(T, NewSum, [NewSum|Acc], Result).\n\nfind_max_distance(Prefixes, CurrentMax, MaxLen) :-\n    add_indices(Prefixes, 1, IndexedPrefixes),\n    IndexedWithZero = [(0, 0)|IndexedPrefixes],\n    findall(Dist, (\n        member((Sum, I), IndexedWithZero),\n        member((Sum, J), IndexedWithZero),\n        I < J,\n        Dist is J - I\n    ), Distances),\n    (Distances = [] -> MaxLen = 0 ; max_list(Distances, MaxLen)).\n\nadd_indices([], _, []).\nadd_indices([H|T], I, [(H, I)|Rest]) :-\n    I1 is I + 1,\n    add_indices(T, I1, Rest).\n\n:- initialization(solve, main).\n", "tests": [{"input": "1\n0", "output": "1"}, {"input": "1\n5", "output": "0"}, {"input": "7\n1 2 -3 3 -1 2 -2", "output": "3"}, {"input": "5\n0 0 0 0 0", "output": "5"}, {"input": "10\n3 -1 -2 5 -3 -2 4 -4 0 0", "output": "10"}, {"input": "6\n-1 2 3 4 5 6", "output": "0"}, {"input": "10\n6 -1 -3 4 -2 2 4 6 -12 -7", "output": "5"}, {"input": "7\n1 -1 3 2 -2 -3 3", "output": "6"}, {"input": "8\n0 1 2 -3 0 0 3 -3", "output": "8"}], "raw_generation": []}
{"task_id": "Prolog/0004", "language": "Prolog", "difficulty": "hard", "instruction": "Read a line and check balanced brackets for ()[]{} with nesting; print YES/NO.", "prompt": "Read a line and check balanced brackets for ()[]{} with nesting; print YES/NO.", "mode": "io", "canonical_solution": ":- set_prolog_flag(verbose, silent).\n:- prompt(_, '').\n:- use_module(library(readln)).\n\nmain :-\n    read_line_to_string(user_input, Line),\n    string_chars(Line, Chars),\n    (check_balanced(Chars, []) -> writeln('YES') ; writeln('NO')),\n    halt.\n\ncheck_balanced([], []).\ncheck_balanced([C|Rest], Stack) :-\n    (opening(C) ->\n        check_balanced(Rest, [C|Stack])\n    ; closing(C) ->\n        (Stack = [Top|NewStack],\n         matches(Top, C) ->\n            check_balanced(Rest, NewStack)\n        ; fail)\n    ; check_balanced(Rest, Stack)).\n\nopening('(').\nopening('[').\nopening('{').\n\nclosing(')').\nclosing(']').\nclosing('}').\n\nmatches('(', ')').\nmatches('[', ']').\nmatches('{', '}').\n\n:- initialization(main).\n", "tests": [{"input": "", "output": "YES"}, {"input": "()", "output": "YES"}, {"input": "{[()]}", "output": "YES"}, {"input": "()[]{}", "output": "YES"}, {"input": "([)]", "output": "NO"}, {"input": "(", "output": "NO"}, {"input": "())", "output": "NO"}, {"input": "(((())))", "output": "YES"}, {"input": ")", "output": "NO"}, {"input": "{[]}()([])", "output": "YES"}], "raw_generation": []}
{"task_id": "Prolog/0005", "language": "Prolog", "difficulty": "hard", "instruction": "Read n and n integers; print the length of the longest increasing subsequence (not necessarily contiguous).", "prompt": "Read n and n integers; print the length of the longest increasing subsequence (not necessarily contiguous).", "mode": "io", "canonical_solution": ":- set_prolog_flag(verbose, silent).\n:- initialization(main, main).\n\nmain :-\n    read_number(N),\n    read_list(N, List),\n    lis_length(List, Length),\n    writeln(Length),\n    halt.\n\nread_number(N) :-\n    read_line_to_string(user_input, Line),\n    number_string(N, Line).\n\nread_list(N, List) :-\n    read_line_to_string(user_input, Line),\n    split_string(Line, \" \", \" \", Strings),\n    length(Strings, N),\n    maplist(number_string, List, Strings).\n\nlis_length(List, Length) :-\n    lis_dp(List, Length).\n\nlis_dp(List, MaxLen) :-\n    length(List, N),\n    (N = 0 -> MaxLen = 0 ;\n     lis_dp_helper(List, 1, N, [], MaxLen)).\n\nlis_dp_helper(List, Idx, N, DP, MaxLen) :-\n    (Idx > N ->\n        max_list(DP, MaxLen)\n    ;\n        nth1(Idx, List, Current),\n        findall(Len,\n            (between(1, Idx, J),\n             J < Idx,\n             nth1(J, List, Prev),\n             nth1(J, DP, PrevLen),\n             Prev < Current,\n             Len = PrevLen),\n            Lens),\n        (Lens = [] -> CurrentLen = 1 ; max_list(Lens, MaxPrev), CurrentLen is MaxPrev + 1),\n        append(DP, [CurrentLen], NewDP),\n        NextIdx is Idx + 1,\n        lis_dp_helper(List, NextIdx, N, NewDP, MaxLen)\n    ).\n", "tests": [{"input": "1\n5\n", "output": "1"}, {"input": "5\n1 2 3 4 5\n", "output": "5"}, {"input": "5\n5 4 3 2 1\n", "output": "1"}, {"input": "6\n7 7 7 7 7 7\n", "output": "1"}, {"input": "7\n3 4 -1 0 6 2 3\n", "output": "4"}, {"input": "8\n-5 -3 -4\n-2 -1 0 1 1\n", "output": "6"}, {"input": "8\n10 22 9 33 21 50 41 60\n", "output": "5"}, {"input": "8\n1 3 5 2 2 2 4 6\n", "output": "4"}, {"input": "8\n5 1 6 2 7 3 8 4\n", "output": "4"}, {"input": "0\n", "output": "0"}, {"input": "4\n1000000000 -1000000000 0 999999999\n", "output": "3"}, {"input": "11\n1 2 2 2 3 4 5 6 0 7 8\n", "output": "8"}], "raw_generation": []}
{"task_id": "Prolog/0006", "language": "Prolog", "difficulty": "hard", "instruction": "Read a CSV line with quotes and commas; parse fields and print field count. Quotes may contain commas and escaped quotes \"\".", "prompt": "Read a CSV line with quotes and commas; parse fields and print field count. Quotes may contain commas and escaped quotes \"\".", "mode": "io", "canonical_solution": ":- set_prolog_flag(double_quotes, codes).\n:- initialization(main, main).\n\nmain :-\n    read_line_to_codes(user_input, Codes),\n    (Codes == end_of_file -> halt(0) ; true),\n    parse_csv_line(Codes, Fields),\n    length(Fields, Count),\n    write(Count), nl,\n    halt(0).\n\nparse_csv_line(Codes, Fields) :-\n    parse_fields(Codes, Fields).\n\nparse_fields([], []) :- !.\nparse_fields(Codes, [Field|Fields]) :-\n    parse_field(Codes, Field, Rest),\n    (Rest = [] -> Fields = [] ;\n     Rest = [44|RestCodes] -> parse_fields(RestCodes, Fields) ;\n     Fields = []).\n\nparse_field([34|Codes], Field, Rest) :- !,\n    parse_quoted_field(Codes, FieldCodes, Rest),\n    atom_codes(Field, FieldCodes).\nparse_field(Codes, Field, Rest) :-\n    parse_unquoted_field(Codes, FieldCodes, Rest),\n    atom_codes(Field, FieldCodes).\n\nparse_quoted_field([], [], []) :- !.\nparse_quoted_field([34,34|Codes], [34|FieldCodes], Rest) :- !,\n    parse_quoted_field(Codes, FieldCodes, Rest).\nparse_quoted_field([34|Codes], [], Codes) :- !.\nparse_quoted_field([C|Codes], [C|FieldCodes], Rest) :-\n    parse_quoted_field(Codes, FieldCodes, Rest).\n\nparse_unquoted_field([], [], []) :- !.\nparse_unquoted_field([44|Codes], [], [44|Codes]) :- !.\nparse_unquoted_field([C|Codes], [C|FieldCodes], Rest) :-\n    parse_unquoted_field(Codes, FieldCodes, Rest).\n", "tests": [{"input": "a,b,c\n", "output": "3\n"}, {"input": "\"a,b\",c\n", "output": "2\n"}, {"input": "\"He said \"\"Hi\"\"\",x\n", "output": "2\n"}, {"input": ",,\n", "output": "3\n"}, {"input": "a,\"b,c\",d,\"e\"\"f\",,\n", "output": "6\n"}, {"input": "\"\"\n", "output": "1\n"}, {"input": ",,,\n", "output": "4\n"}, {"input": "\n", "output": "1\n"}, {"input": "\"a,\"\"b\"\",c\",d\n", "output": "2\n"}, {"input": "\"\",\"\",x\n", "output": "3\n"}], "raw_generation": []}
{"task_id": "Prolog/0007", "language": "Prolog", "difficulty": "hard", "instruction": "Read a string s and integer k; print the lexicographically smallest substring of length k.", "prompt": "Read a string s and integer k; print the lexicographically smallest substring of length k.", "mode": "io", "canonical_solution": ":- set_prolog_flag(verbose, silent).\n:- prompt(_, '').\n:- use_module(library(readutil)).\n\nmain :-\n    read_line_to_string(user_input, S),\n    read_string(user_input, \"\\n\", \"\\r\", _, KStr),\n    number_string(K, KStr),\n    find_smallest_substring(S, K, Result),\n    writeln(Result),\n    halt.\n\nfind_smallest_substring(S, K, Result) :-\n    string_length(S, Len),\n    MaxStart is Len - K,\n    findall(Sub, (between(0, MaxStart, I), sub_string(S, I, K, _, Sub)), Subs),\n    sort(Subs, [Result|_]).\n\n:- main.\n", "tests": [{"input": "abcde\n3", "output": "abc"}, {"input": "bcaaad\n2", "output": "aa"}, {"input": "aaaaa\n2", "output": "aa"}, {"input": "babab\n3", "output": "aba"}, {"input": "zzzaaaazz\n4", "output": "aaaa"}, {"input": "qwerty\n2", "output": "er"}, {"input": "b2a1c\n2", "output": "1c"}, {"input": "banana\n1", "output": "a"}, {"input": "banana\n6", "output": "banana"}, {"input": "cbaabc\n2", "output": "aa"}], "raw_generation": []}
{"task_id": "Prolog/0008", "language": "Prolog", "difficulty": "hard", "instruction": "Read n and then n intervals [l,r]; merge and output total covered length.", "prompt": "Read n and then n intervals [l,r]; merge and output total covered length.", "mode": "io", "canonical_solution": ":- set_prolog_flag(verbose, silent).\n:- prompt(_, '').\n:- use_module(library(readutil)).\n\nmain :-\n    read_line_to_string(user_input, Line1),\n    number_string(N, Line1),\n    read_intervals(N, Intervals),\n    sort(Intervals, Sorted),\n    merge_intervals(Sorted, Merged),\n    total_length(Merged, Total),\n    writeln(Total),\n    halt.\n\nread_intervals(0, []) :- !.\nread_intervals(N, [[L,R]|Rest]) :-\n    N > 0,\n    read_line_to_string(user_input, Line),\n    split_string(Line, \" \", \" \", Parts),\n    maplist(number_string, [L, R], Parts),\n    N1 is N - 1,\n    read_intervals(N1, Rest).\n\nmerge_intervals([], []) :- !.\nmerge_intervals([[L,R]], [[L,R]]) :- !.\nmerge_intervals([[L1,R1],[L2,R2]|Rest], Merged) :-\n    L2 =< R1,\n    !,\n    MaxR is max(R1, R2),\n    merge_intervals([[L1,MaxR]|Rest], Merged).\nmerge_intervals([[L1,R1]|Rest], [[L1,R1]|Merged]) :-\n    merge_intervals(Rest, Merged).\n\ntotal_length([], 0).\ntotal_length([[L,R]|Rest], Total) :-\n    total_length(Rest, RestTotal),\n    Total is RestTotal + (R - L).\n\n:- initialization(main).\n", "tests": [{"input": "3\n1 4\n2 6\n8 10", "output": "7"}, {"input": "4\n1 2\n2 5\n5 5\n5 7", "output": "6"}, {"input": "3\n0 1\n2 3\n4 8", "output": "6"}, {"input": "4\n1 10\n2 3\n4 5\n6 9", "output": "9"}, {"input": "3\n-5 -1\n-3 2\n3 3", "output": "7"}, {"input": "1\n100 200", "output": "100"}, {"input": "3\n5 5\n5 5\n5 5", "output": "0"}, {"input": "4\n1 3\n2 4\n4 6\n6 9", "output": "8"}, {"input": "2\n0 1000000000\n999999999 1000000001", "output": "1000000001"}, {"input": "6\n-10 -8\n-9 -5\n-4 0\n0 0\n1 3\n2 2", "output": "11"}], "raw_generation": []}
{"task_id": "Prolog/0009", "language": "Prolog", "difficulty": "hard", "instruction": "Read a string; print 1 if it is a valid IPv4 address, else 0.", "prompt": "Read a string; print 1 if it is a valid IPv4 address, else 0.", "mode": "io", "canonical_solution": ":- set_prolog_flag(verbose, silent).\n:- initialization(main, main).\n\nmain :-\n    read_line_to_string(user_input, Line),\n    (valid_ipv4(Line) -> write('1') ; write('0')),\n    nl,\n    halt.\n\nvalid_ipv4(String) :-\n    split_string(String, \".\", \"\", Parts),\n    length(Parts, 4),\n    maplist(valid_octet, Parts).\n\nvalid_octet(String) :-\n    string_length(String, Len),\n    Len > 0,\n    Len =< 3,\n    atom_string(Atom, String),\n    atom_number(Atom, Num),\n    integer(Num),\n    Num >= 0,\n    Num =< 255,\n    \\+ leading_zero(String, Num).\n\nleading_zero(String, Num) :-\n    string_length(String, Len),\n    Len > 1,\n    sub_string(String, 0, 1, _, \"0\"),\n    Num >= 0.\n", "tests": [{"input": "192.168.1.1", "output": "1"}, {"input": "255.255.255.255", "output": "1"}, {"input": "0.0.0.0", "output": "1"}, {"input": "10.0.0.0", "output": "1"}, {"input": "256.100.100.100", "output": "0"}, {"input": "192.168.01.1", "output": "0"}, {"input": "1.2.3", "output": "0"}, {"input": "1.2.3.4.5", "output": "0"}, {"input": "1..3.4", "output": "0"}, {"input": "1.2.3.a", "output": "0"}, {"input": "-1.2.3.4", "output": "0"}, {"input": "1.2.3.4 ", "output": "0"}, {"input": " 1.2.3.4", "output": "0"}, {"input": "00.0.0.0", "output": "0"}, {"input": "10.0.0.00", "output": "0"}, {"input": "255.255.255.256", "output": "0"}], "raw_generation": []}
{"task_id": "Prolog/0010", "language": "Prolog", "difficulty": "hard", "instruction": "Read a line; print word frequencies sorted by (-count, word).", "prompt": "Read a line; print word frequencies sorted by (-count, word).", "mode": "io", "canonical_solution": ":- set_prolog_flag(verbose, silent).\n:- prompt(_, '').\n:- use_module(library(readutil)).\n:- use_module(library(lists)).\n\nsplit_words(Line, Words) :-\n    split_string(Line, \" \\t\\n\\r\", \" \\t\\n\\r\", Strings),\n    maplist(atom_string, Words, Strings).\n\ncount_words([], []).\ncount_words([W|Ws], Counts) :-\n    count_words(Ws, RestCounts),\n    (   select(W-N, RestCounts, Rest)\n    ->  N1 is N + 1,\n        Counts = [W-N1|Rest]\n    ;   Counts = [W-1|RestCounts]\n    ).\n\ncompare_entries(Order, W1-C1, W2-C2) :-\n    (   C1 > C2\n    ->  Order = (<)\n    ;   C1 < C2\n    ->  Order = (>)\n    ;   compare(Order, W1, W2)\n    ).\n\nmain :-\n    read_line_to_string(user_input, Line),\n    (   Line \\= end_of_file\n    ->  split_words(Line, Words),\n        count_words(Words, Counts),\n        predsort(compare_entries, Counts, Sorted),\n        forall(member(Word-Count, Sorted),\n               format('~w ~w~n', [Word, Count]))\n    ;   true\n    ),\n    halt.\n\n:- initialization(main).\n", "tests": [{"input": "one two two three three three", "output": "three 3\ntwo 2\none 1\n"}, {"input": "", "output": ""}, {"input": "b a b a c", "output": "a 2\nb 2\nc 1\n"}, {"input": "cat   dog\tcat\t  bird", "output": "cat 2\nbird 1\ndog 1\n"}, {"input": "hello", "output": "hello 1\n"}, {"input": "x y z x y x", "output": "x 3\ny 2\nz 1\n"}, {"input": "   alpha beta   alpha   ", "output": "alpha 2\nbeta 1\n"}, {"input": "m l k j", "output": "j 1\nk 1\nl 1\nm 1\n"}, {"input": "a2 a10 a1 a2", "output": "a2 2\na1 1\na10 1\n"}], "raw_generation": []}
{"task_id": "Prolog/0011", "language": "Prolog", "difficulty": "hard", "instruction": "Given n,m and a grid of '.' and '#', count connected components (4-direction).", "prompt": "Given n,m and a grid of '.' and '#', count connected components (4-direction).", "mode": "io", "canonical_solution": ":- set_prolog_flag(verbose, silent).\n:- initialization(main, main).\n\nmain :-\n    read_string(user_input, _, Input),\n    split_string(Input, \"\\n\", \"\\n\", Lines),\n    Lines = [FirstLine | RestLines],\n    split_string(FirstLine, \" \", \" \", [NStr, MStr]),\n    number_string(N, NStr),\n    number_string(M, MStr),\n    parse_grid(RestLines, 1, Grid),\n    count_components(Grid, N, M, Count),\n    writeln(Count),\n    halt.\n\nparse_grid([], _, []).\nparse_grid([Line | Rest], Row, Grid) :-\n    (   Line \\= \"\"\n    ->  string_chars(Line, Chars),\n        parse_row(Chars, Row, 1, RowCells),\n        parse_grid(Rest, Row1, RestGrid),\n        Row1 is Row + 1,\n        append(RowCells, RestGrid, Grid)\n    ;   parse_grid(Rest, Row, Grid)\n    ).\n\nparse_row([], _, _, []).\nparse_row([Char | Rest], Row, Col, [cell(Row, Col, Char) | RestCells]) :-\n    Col1 is Col + 1,\n    parse_row(Rest, Row, Col1, RestCells).\n\ncount_components(Grid, N, M, Count) :-\n    count_components(Grid, N, M, [], Count).\n\ncount_components([], _, _, _, 0).\ncount_components([cell(R, C, '.') | Rest], N, M, Visited, Count) :-\n    \\+ member((R, C), Visited),\n    !,\n    bfs([(R, C)], N, M, Visited, NewVisited),\n    count_components(Rest, N, M, NewVisited, RestCount),\n    Count is RestCount + 1.\ncount_components([cell(R, C, _) | Rest], N, M, Visited, Count) :-\n    (   member((R, C), Visited)\n    ->  NewVisited = Visited\n    ;   NewVisited = [(R, C) | Visited]\n    ),\n    count_components(Rest, N, M, NewVisited, Count).\n\nbfs([], _, _, Visited, Visited).\nbfs([Pos | Queue], N, M, Visited, FinalVisited) :-\n    Pos = (R, C),\n    (   member(Pos, Visited)\n    ->  bfs(Queue, N, M, Visited, FinalVisited)\n    ;   get_neighbors(R, C, N, M, Neighbors),\n        append(Queue, Neighbors, NewQueue),\n        bfs(NewQueue, N, M, [Pos | Visited], FinalVisited)\n    ).\n\nget_neighbors(R, C, N, M, Neighbors) :-\n    R1 is R - 1, R2 is R + 1,\n    C1 is C - 1, C2 is C + 1,\n    findall((NR, NC),\n            (   (NR = R1, NC = C, R1 >= 1)\n            ;   (NR = R2, NC = C, R2 =< N)\n            ;   (NR = R, NC = C1, C1 >= 1)\n            ;   (NR = R, NC = C2, C2 =< M)\n            ),\n            Neighbors).\n", "tests": [{"input": "1 1\n.\n", "output": "0\n"}, {"input": "1 1\n#\n", "output": "1\n"}, {"input": "3 3\n#.#\n.#.\n#.#\n", "output": "5\n"}, {"input": "3 4\n####\n####\n....\n", "output": "1\n"}, {"input": "4 5\n##...\n##...\n...##\n...##\n", "output": "2\n"}, {"input": "3 5\n#.#.#\n#.#.#\n#.#.#\n", "output": "3\n"}, {"input": "5 5\n.....\n.....\n.....\n.....\n.....\n", "output": "0\n"}, {"input": "5 5\n#####\n#...#\n#...#\n#...#\n#####\n", "output": "1\n"}, {"input": "1 10\n#.#.#.#.#.\n", "output": "5\n"}, {"input": "2 1\n#\n#\n", "output": "1\n"}], "raw_generation": []}
{"task_id": "Prolog/0012", "language": "Prolog", "difficulty": "hard", "instruction": "Read a line; run-length encode (RLE) it as <char><count> without separators.", "prompt": "Read a line; run-length encode (RLE) it as <char><count> without separators.", "mode": "io", "canonical_solution": ":- set_prolog_flag(verbose, silent).\n:- prompt(_, '').\n:- use_module(library(readutil)).\n\nrun_length_encode([], []).\nrun_length_encode([H|T], Result) :-\n    count_char(H, [H|T], Count, Rest),\n    run_length_encode(Rest, RestResult),\n    atom_chars(Count, CountChars),\n    append([H|CountChars], RestResult, Result).\n\ncount_char(_, [], 0, []).\ncount_char(C, [C|T], Count, Rest) :-\n    !,\n    count_char(C, T, Count1, Rest),\n    Count is Count1 + 1.\ncount_char(_, L, 0, L).\n\nmain :-\n    read_line_to_string(user_input, Line),\n    (Line \\= end_of_file ->\n        string_chars(Line, Chars),\n        run_length_encode(Chars, Encoded),\n        atom_chars(Output, Encoded),\n        write(Output), nl\n    ; true),\n    halt.\n\n:- main.\n", "tests": [{"input": "AAAABCC", "output": "A4B1C2"}, {"input": "abc", "output": "a1b1c1"}, {"input": "Z", "output": "Z1"}, {"input": "111223", "output": "132231"}, {"input": "a  b", "output": "a1 2b1"}, {"input": "!!@@@###", "output": "!2@3#3"}, {"input": "", "output": ""}, {"input": "aaaaaaaaaaa", "output": "a11"}, {"input": "AaAa", "output": "A1a1A1a1"}, {"input": "\t\tab", "output": "\t2a1b1"}], "raw_generation": []}
{"task_id": "Prolog/0013", "language": "Prolog", "difficulty": "hard", "instruction": "Read two big integers (up to 10^500) as strings; print their sum.", "prompt": "Read two big integers (up to 10^500) as strings; print their sum.", "mode": "io", "canonical_solution": ":- set_prolog_flag(encoding, utf8).\n:- set_prolog_flag(double_quotes, chars).\n\nread_line(Chars) :-\n    read_line_to_string(user_input, String),\n    string_chars(String, Chars).\n\nchar_to_digit(C, D) :- char_code(C, Code), D is Code - 48.\n\ndigits_to_number(Digits, Number) :-\n    reverse(Digits, Rev),\n    digits_to_number_acc(Rev, 0, Number).\n\ndigits_to_number_acc([], Acc, Acc).\ndigits_to_number_acc([D|Ds], Acc, Number) :-\n    NewAcc is Acc * 10 + D,\n    digits_to_number_acc(Ds, NewAcc, Number).\n\nadd_digits([], [], 0, []).\nadd_digits([], [], Carry, [Carry]) :- Carry > 0.\nadd_digits([D1|D1s], [], Carry, Result) :-\n    add_digits([D1|D1s], [0], Carry, Result).\nadd_digits([], [D2|D2s], Carry, Result) :-\n    add_digits([0], [D2|D2s], Carry, Result).\nadd_digits([D1|D1s], [D2|D2s], Carry, [R|Rs]) :-\n    Sum is D1 + D2 + Carry,\n    R is Sum mod 10,\n    NewCarry is Sum // 10,\n    add_digits(D1s, D2s, NewCarry, Rs).\n\nprint_digits([]).\nprint_digits([D|Ds]) :-\n    print_digits(Ds),\n    write(D).\n\nmain :-\n    read_line(Line1),\n    read_line(Line2),\n    maplist(char_to_digit, Line1, Digits1),\n    maplist(char_to_digit, Line2, Digits2),\n    reverse(Digits1, Rev1),\n    reverse(Digits2, Rev2),\n    add_digits(Rev1, Rev2, 0, ResultRev),\n    reverse(ResultRev, Result),\n    print_digits(Result),\n    nl,\n    halt.\n\n:- initialization(main).\n", "tests": [{"input": "1\n2\n", "output": "3"}, {"input": "0\n0\n", "output": "0"}, {"input": "999\n1\n", "output": "1000"}, {"input": "12345678901234567890\n98765432109876543210\n", "output": "111111111011111111100"}, {"input": "0000123\n000004321\n", "output": "4444"}, {"input": "99999999999999999999999999999999999999999999999999\n1\n", "output": "100000000000000000000000000000000000000000000000000"}, {"input": "555555555555555555555555555555555555555555555555555555555555\n444444444444444444444444444444444444444444444444444444444444\n", "output": "999999999999999999999999999999999999999999999999999999999999"}, {"input": "42 58", "output": "100"}, {"input": "1000\n99\n", "output": "1099"}], "raw_generation": []}
{"task_id": "Prolog/0014", "language": "Prolog", "difficulty": "hard", "instruction": "Given n,m and edges (1-indexed), output a topological ordering or print -1 if cycle.", "prompt": "Given n,m and edges (1-indexed), output a topological ordering or print -1 if cycle.", "mode": "io", "canonical_solution": ":- initialization(main, main).\n\nmain :-\n    read(N),\n    read(M),\n    read_edges(M, Edges),\n    build_graph(N, Edges, Graph, InDegree),\n    topological_sort(N, Graph, InDegree, Result),\n    (Result = [] ->\n        writeln(-1)\n    ;\n        print_result(Result)\n    ),\n    halt.\n\nread_edges(0, []) :- !.\nread_edges(M, [U-V|Rest]) :-\n    M > 0,\n    read(U),\n    read(V),\n    M1 is M - 1,\n    read_edges(M1, Rest).\n\nbuild_graph(N, Edges, Graph, InDegree) :-\n    build_empty_graph(N, Graph),\n    build_indegree(N, InDegree),\n    add_edges(Edges, Graph, InDegree).\n\nbuild_empty_graph(N, Graph) :-\n    functor(Graph, graph, N),\n    init_adjacency(N, Graph).\n\ninit_adjacency(0, _) :- !.\ninit_adjacency(I, Graph) :-\n    I > 0,\n    arg(I, Graph, []),\n    I1 is I - 1,\n    init_adjacency(I1, Graph).\n\nbuild_indegree(N, InDegree) :-\n    functor(InDegree, indegree, N),\n    init_indegree(N, InDegree).\n\ninit_indegree(0, _) :- !.\ninit_indegree(I, InDegree) :-\n    I > 0,\n    arg(I, InDegree, 0),\n    I1 is I - 1,\n    init_indegree(I1, InDegree).\n\nadd_edges([], _, _).\nadd_edges([U-V|Rest], Graph, InDegree) :-\n    arg(U, Graph, AdjU),\n    (member(V, AdjU) -> true ; arg(U, Graph, [V|AdjU])),\n    arg(V, InDegree, DegV),\n    DegV1 is DegV + 1,\n    nb_setarg(V, InDegree, DegV1),\n    add_edges(Rest, Graph, InDegree).\n\ntopological_sort(N, Graph, InDegree, Result) :-\n    find_zero_indegree(N, InDegree, Queue),\n    kahn_sort(Queue, Graph, InDegree, [], Result, 0, N).\n\nfind_zero_indegree(N, InDegree, Queue) :-\n    findall(I, (between(1, N, I), arg(I, InDegree, 0)), Queue).\n\nkahn_sort([], _, _, Acc, Result, Count, N) :-\n    (Count =:= N ->\n        reverse(Acc, Result)\n    ;\n        Result = []\n    ).\nkahn_sort([U|Queue], Graph, InDegree, Acc, Result, Count, N) :-\n    Count1 is Count + 1,\n    arg(U, Graph, Neighbors),\n    process_neighbors(Neighbors, InDegree, NewQueue),\n    append(Queue, NewQueue, NextQueue),\n    kahn_sort(NextQueue, Graph, InDegree, [U|Acc], Result, Count1, N).\n\nprocess_neighbors([], _, []).\nprocess_neighbors([V|Rest], InDegree, Queue) :-\n    arg(V, InDegree, DegV),\n    DegV1 is DegV - 1,\n    nb_setarg(V, InDegree, DegV1),\n    (DegV1 =:= 0 ->\n        Queue = [V|RestQueue]\n    ;\n        Queue = RestQueue\n    ),\n    process_neighbors(Rest, InDegree, RestQueue).\n\nprint_result([]) :- nl.\nprint_result([H|T]) :-\n    write(H),\n    (T = [] -> nl ; (write(' '), print_result(T))).\n", "tests": [{"input": "4 3\n1 2\n2 3\n3 4", "output": "1 2 3 4"}, {"input": "3 3\n1 2\n2 3\n3 1", "output": "-1"}, {"input": "5 3\n1 2\n3 4\n3 5", "output": "1 2 3 4 5"}, {"input": "4 0", "output": "1 2 3 4"}, {"input": "3 1\n2 2", "output": "-1"}, {"input": "6 6\n1 4\n2 4\n2 5\n3 5\n4 6\n5 6", "output": "1 2 3 4 5 6"}, {"input": "5 4\n5 1\n1 2\n5 3\n3 4", "output": "5 1 3 4 2"}, {"input": "7 5\n2 3\n2 4\n4 5\n6 7\n1 4", "output": "1 2 6 4 3 5 7"}, {"input": "3 3\n1 2\n1 2\n2 3", "output": "1 2 3"}], "raw_generation": []}
{"task_id": "Prolog/0015", "language": "Prolog", "difficulty": "hard", "instruction": "Read multiple lines until EOF; output the line with the maximum number of distinct characters (break ties by earliest).", "prompt": "Read multiple lines until EOF; output the line with the maximum number of distinct characters (break ties by earliest).", "mode": "io", "canonical_solution": ":- set_stream(user_input, encoding(utf8)).\n:- set_stream(user_output, encoding(utf8)).\n\nread_lines(Lines) :-\n    read_line_to_string(user_input, Line),\n    (   Line == end_of_file\n    ->  Lines = []\n    ;   Lines = [Line|Rest],\n        read_lines(Rest)\n    ).\n\ndistinct_chars(String, Count) :-\n    string_chars(String, Chars),\n    list_to_set(Chars, UniqueChars),\n    length(UniqueChars, Count).\n\nfind_max_line([], _, _, Result, Result).\nfind_max_line([Line|Rest], MaxCount, MaxLine, _, Result) :-\n    distinct_chars(Line, Count),\n    Count > MaxCount,\n    !,\n    find_max_line(Rest, Count, Line, Line, Result).\nfind_max_line([_|Rest], MaxCount, MaxLine, _, Result) :-\n    find_max_line(Rest, MaxCount, MaxLine, MaxLine, Result).\n\nmain :-\n    read_lines(Lines),\n    (   Lines = []\n    ->  true\n    ;   Lines = [First|Rest],\n        distinct_chars(First, FirstCount),\n        find_max_line(Rest, FirstCount, First, First, MaxLine),\n        writeln(MaxLine)\n    ).\n\n:- initialization(main, main).\n", "tests": [{"input": "hello", "output": "hello"}, {"input": "abc\nab\nabcd\naabbcc\nABCD", "output": "abcd"}, {"input": "aa aa\nab ab\nab  ab\n a b c", "output": " a b c"}, {"input": "12345\n112233\n1a2b3c!\n!!!@@@", "output": "1a2b3c!"}, {"input": "abcABC\naaaaAAA\nAbcabc", "output": "abcABC"}, {"input": "\na\n\nbb", "output": "a"}, {"input": "침and칰\nnandu\n游游땎游땏游때\n游游땎游땏游때游땑", "output": "침and칰"}, {"input": "aaaa\nbbbbc\ncccdde\nxyz123", "output": "xyz123"}, {"input": "aaaaa\nabcde fghij\nabcde fghij k\nabcde fghij ka", "output": "abcde fghij k"}, {"input": "...,,,;;;!!!\n.:,!?\n.:,:!", "output": ".:,!?"}], "raw_generation": []}
{"task_id": "Prolog/0016", "language": "Prolog", "difficulty": "hard", "instruction": "Read a line; evaluate a simple expression with + - * / and parentheses (integers, no unary minus), print result.", "prompt": "Read a line; evaluate a simple expression with + - * / and parentheses (integers, no unary minus), print result.", "mode": "io", "canonical_solution": ":- set_prolog_flag(verbose, silent).\n:- initialization(main, main).\n\nmain :-\n    read_line_to_string(user_input, Line),\n    string_chars(Line, Chars),\n    phrase(expr(Result), Chars, []),\n    writeln(Result),\n    halt.\n\nexpr(Result) --> term(T), expr_rest(T, Result).\nexpr_rest(Acc, Result) --> ['+'], !, term(T), { Acc1 is Acc + T }, expr_rest(Acc1, Result).\nexpr_rest(Acc, Result) --> ['-'], !, term(T), { Acc1 is Acc - T }, expr_rest(Acc1, Result).\nexpr_rest(Result, Result) --> [].\n\nterm(Result) --> factor(F), term_rest(F, Result).\nterm_rest(Acc, Result) --> ['*'], !, factor(F), { Acc1 is Acc * F }, term_rest(Acc1, Result).\nterm_rest(Acc, Result) --> ['/'], !, factor(F), { Acc1 is Acc / F }, term_rest(Acc1, Result).\nterm_rest(Result, Result) --> [].\n\nfactor(Result) --> ['('], !, expr(Result), [')'].\nfactor(N) --> digit(D), number(D, N).\n\nnumber(Acc, N) --> digit(D), !, { Acc1 is Acc * 10 + D }, number(Acc1, N).\nnumber(N, N) --> [].\n\ndigit(D) --> [C], { char_type(C, digit), atom_number(C, D) }.\n", "tests": [{"input": "1+2", "output": "3"}, {"input": "7+5*2", "output": "17"}, {"input": "(3+4)*5", "output": "35"}, {"input": "8/2+3", "output": "7"}, {"input": "((2+3)*(4+6))/(5)", "output": "10"}, {"input": "12345+67890-11111", "output": "69124"}, {"input": "42/(2*3)", "output": "7"}, {"input": "20/5/2", "output": "2"}, {"input": "18-3-4", "output": "11"}, {"input": "6*(2+3*4)-8/2", "output": "80"}, {"input": "(1+2)*(3+(4*5))", "output": "69"}, {"input": "3-10*2+7", "output": "-10"}, {"input": "  15 +  3 * ( 2 + 1 ) ", "output": "24"}], "raw_generation": []}
{"task_id": "Prolog/0017", "language": "Prolog", "difficulty": "hard", "instruction": "Read string s; print length of the longest substring without repeating characters.", "prompt": "Read string s; print length of the longest substring without repeating characters.", "mode": "io", "canonical_solution": ":- set_prolog_flag(verbose, silent).\n:- prompt(_, '').\n:- use_module(library(readutil)).\n\nmain :-\n    read_line_to_string(user_input, S),\n    string_chars(S, Chars),\n    longest_unique_substring(Chars, Length),\n    writeln(Length),\n    halt.\n\nlongest_unique_substring(Chars, MaxLength) :-\n    longest_unique_substring(Chars, 0, 0, [], MaxLength).\n\nlongest_unique_substring([], _, MaxSoFar, _, MaxSoFar).\nlongest_unique_substring([C|Rest], Start, MaxSoFar, Window, MaxLength) :-\n    (   member(C, Window)\n    ->  remove_until(Window, C, NewWindow),\n        append(NewWindow, [C], UpdatedWindow),\n        length(UpdatedWindow, CurrentLen),\n        NewMax is max(MaxSoFar, CurrentLen),\n        longest_unique_substring(Rest, Start, NewMax, UpdatedWindow, MaxLength)\n    ;   append(Window, [C], UpdatedWindow),\n        length(UpdatedWindow, CurrentLen),\n        NewMax is max(MaxSoFar, CurrentLen),\n        longest_unique_substring(Rest, Start, NewMax, UpdatedWindow, MaxLength)\n    ).\n\nremove_until([], _, []).\nremove_until([C|Rest], C, Rest) :- !.\nremove_until([_|Rest], C, Result) :-\n    remove_until(Rest, C, Result).\n\n:- initialization(main).\n", "tests": [{"input": "", "output": "0"}, {"input": "bbbbb", "output": "1"}, {"input": "abcabcbb", "output": "3"}, {"input": "pwwkew", "output": "3"}, {"input": "tmmzuxt", "output": "5"}, {"input": "dvdf", "output": "3"}, {"input": "AaBbAa", "output": "4"}, {"input": " ", "output": "1"}, {"input": "a b c", "output": "3"}, {"input": "123451234", "output": "5"}, {"input": "游游땎游땏游", "output": "3"}, {"input": "a!@#a!", "output": "4"}, {"input": "anviaj", "output": "5"}, {"input": "abcdefghijklmnopqrstuvwxyz", "output": "26"}, {"input": "abba", "output": "2"}], "raw_generation": []}
{"task_id": "Prolog/0018", "language": "Prolog", "difficulty": "easy", "instruction": "Read n then n integers. Print the number of distinct values.", "prompt": "Read n then n integers. Print the number of distinct values.", "mode": "io", "canonical_solution": "```prolog\n:- set_prolog_flag(verbose, silent).\n:- prompt(_, '').\n:- use_module(library(readutil)).\n\nmain :-\n    read_line_to_string(user_input, Line1),\n    number_string(N, Line1),\n    read_line_to_string(user_input, Line2),\n    split_string(Line2, \" \", \"\", Parts),\n    maplist(number_string, Numbers, Parts),\n    list_to_set(Numbers, Set),\n    length(Set, Count),\n    writeln(Count),\n    halt.\n\n:- initialization(main).\n```", "tests": [{"input": "5\n1 2 3 2 1\n", "output": "3\n"}, {"input": "4\n7 7 7 7\n", "output": "1\n"}, {"input": "6\n-1 0 1 2 -2 3\n", "output": "6\n"}, {"input": "7\n1000000000 -1000000000 0\n1000000000 42 42 -1000000000\n", "output": "4\n"}, {"input": "1\n999\n", "output": "1\n"}, {"input": "0\n", "output": "0\n"}, {"input": "10\n5 1 5 2 3 2 4 3 5 1\n", "output": "5\n"}, {"input": "\n8\n-5 -5   -5   5 5  0 1   -1   \n", "output": "5\n"}], "raw_generation": []}
{"task_id": "Prolog/0019", "language": "Prolog", "difficulty": "easy", "instruction": "Read m then m lines of 'key value'; then read q and q queries; for each key print value or 'NA'.", "prompt": "Read m then m lines of 'key value'; then read q and q queries; for each key print value or 'NA'.", "mode": "io", "canonical_solution": "```prolog\n:- set_prolog_flag(verbose, silent).\n:- prompt(_, '').\n:- use_module(library(readutil)).\n\nmain :-\n    read_line_to_string(user_input, M_Line),\n    number_string(M, M_Line),\n    read_entries(M, Entries),\n    read_line_to_string(user_input, Q_Line),\n    number_string(Q, Q_Line),\n    process_queries(Q, Entries),\n    halt.\n\nread_entries(0, []) :- !.\nread_entries(N, [Key-Value|Rest]) :-\n    N > 0,\n    read_line_to_string(user_input, Line),\n    split_string(Line, \" \", \"\", [KeyStr, ValueStr]),\n    atom_string(Key, KeyStr),\n    atom_string(Value, ValueStr),\n    N1 is N - 1,\n    read_entries(N1, Rest).\n\nprocess_queries(0, _) :- !.\nprocess_queries(N, Entries) :-\n    N > 0,\n    read_line_to_string(user_input, Line),\n    atom_string(Key, Line),\n    (member(Key-Value, Entries) -> writeln(Value) ; writeln('NA')),\n    N1 is N - 1,\n    process_queries(N1, Entries).\n\n:- main.\n```", "tests": [{"input": "3\napple red\nbanana yellow\ngrape purple\n4\napple\norange\nbanana\ngrape\n", "output": "red\nNA\nyellow\npurple\n"}, {"input": "0\n5\na\nb\nc\nd\ne\n", "output": "NA\nNA\nNA\nNA\nNA\n"}, {"input": "4\n1 one\n2 two\n3 three\n10 ten\n6\n1\n2\n4\n10\n3\n11\n", "output": "one\ntwo\nNA\nten\nthree\nNA\n"}, {"input": "5\nKey value1\nkey value2\nKEY value3\nkey value4\nKey value5\n6\nKey\nkey\nKEY\nkEy\nunknown\nKey\n", "output": "value5\nvalue4\nvalue3\nNA\nNA\nvalue5\n"}, {"input": "6\nx 123\ny -45\nz 0\nalpha A_B-1\nbeta yes\ngamma no\n8\nx\ny\nz\nalpha\nbeta\ngamma\ndelta\nA_B-1\n", "output": "123\n-45\n0\nA_B-1\nyes\nno\nNA\nNA\n"}, {"input": "3\na 1\nb 2\na 3\n0\n", "output": ""}, {"input": "4\nuser_name John\nuser-id 007\nemail user@example.com\npath /usr/bin\n5\nuser_name\nuser-id\nemail\npath\nurl\n", "output": "John\n007\nuser@example.com\n/usr/bin\nNA\n"}, {"input": "10\nk1 v1\nk2 v2\nk3 v3\nk4 v4\nk5 v5\nk1 new1\nk6 v6\nk7 v7\nk8 v8\nk9 v9\n10\nk1\nk2\nk10\nk5\nk6\nk9\nk8\nk0\nk3\nk4\n", "output": "new1\nv2\nNA\nv5\nv6\nv9\nv8\nNA\nv3\nv4\n"}], "raw_generation": []}
{"task_id": "Prolog/0020", "language": "Prolog", "difficulty": "easy", "instruction": "Read a line containing integers separated by commas and/or spaces; print their sum.", "prompt": "Read a line containing integers separated by commas and/or spaces; print their sum.", "mode": "io", "canonical_solution": "```prolog\n:- set_prolog_flag(verbose, silent).\n:- prompt(_, '').\n:- use_module(library(readln)).\n\nmain :-\n    read_line_to_string(user_input, Line),\n    split_string(Line, \", \", \", \", Parts),\n    maplist(number_string, Numbers, Parts),\n    sum_list(Numbers, Sum),\n    writeln(Sum),\n    halt.\n\n:- initialization(main).\n```", "tests": [{"input": "1 2 3", "output": "6"}, {"input": "1,2,3", "output": "6"}, {"input": "10, 20 30 ,40", "output": "100"}, {"input": "-5, 10, -15", "output": "-10"}, {"input": "0,0 0", "output": "0"}, {"input": "999999999, 1", "output": "1000000000"}, {"input": "42", "output": "42"}, {"input": "  7 , 8 ,9  ", "output": "24"}], "raw_generation": []}
{"task_id": "Prolog/0021", "language": "Prolog", "difficulty": "easy", "instruction": "Read a line and print 'YES' if it is a palindrome ignoring non-alphanumerics and case, else 'NO'.", "prompt": "Read a line and print 'YES' if it is a palindrome ignoring non-alphanumerics and case, else 'NO'.", "mode": "io", "canonical_solution": "```prolog\n:- set_prolog_flag(verbose, silent).\n:- prompt(_, '').\n:- use_module(library(readutil)).\n\nmain :-\n    read_line_to_string(user_input, Line),\n    (Line \\= end_of_file ->\n        filter_alphanumeric(Line, Filtered),\n        string_lower(Filtered, Lower),\n        string_chars(Lower, Chars),\n        (is_palindrome(Chars) -> writeln('YES') ; writeln('NO'))\n    ; true),\n    halt.\n\nfilter_alphanumeric(String, Filtered) :-\n    string_chars(String, Chars),\n    include(is_alnum, Chars, FilteredChars),\n    string_chars(Filtered, FilteredChars).\n\nis_alnum(C) :-\n    char_type(C, alnum).\n\nis_palindrome(List) :-\n    reverse(List, List).\n\n:- main.\n```", "tests": [{"input": "A man, a plan, a canal: Panama", "output": "YES"}, {"input": "race a car", "output": "NO"}, {"input": "No 'x' in Nixon", "output": "YES"}, {"input": ".,!?", "output": "YES"}, {"input": "", "output": "YES"}, {"input": "12321", "output": "YES"}, {"input": "1231", "output": "NO"}, {"input": "AbBa", "output": "YES"}, {"input": "游떀 a!!A 游떀", "output": "YES"}, {"input": "Not a palindrome!", "output": "NO"}], "raw_generation": []}
{"task_id": "Prolog/0022", "language": "Prolog", "difficulty": "easy", "instruction": "Read a line and print 'YES' if it is a palindrome ignoring non-alphanumerics and case, else 'NO'.", "prompt": "Read a line and print 'YES' if it is a palindrome ignoring non-alphanumerics and case, else 'NO'.", "mode": "io", "canonical_solution": "```prolog\n:- set_prolog_flag(verbose, silent).\n:- initialization(main, main).\n\nmain :-\n    read_line_to_string(user_input, Line),\n    (   Line \\= end_of_file\n    ->  filter_alphanumeric(Line, Filtered),\n        string_lower(Filtered, Lower),\n        string_chars(Lower, Chars),\n        (   is_palindrome(Chars)\n        ->  writeln('YES')\n        ;   writeln('NO')\n        )\n    ;   true\n    ),\n    halt.\n\nfilter_alphanumeric(String, Filtered) :-\n    string_chars(String, Chars),\n    include(is_alnum, Chars, FilteredChars),\n    string_chars(Filtered, FilteredChars).\n\nis_alnum(C) :-\n    char_type(C, alnum).\n\nis_palindrome(List) :-\n    reverse(List, List).\n```", "tests": [{"input": "A man, a plan, a canal: Panama!", "output": "YES"}, {"input": "race a car", "output": "NO"}, {"input": "No 'x' in Nixon", "output": "YES"}, {"input": ".,; ", "output": "YES"}, {"input": "12321", "output": "YES"}, {"input": "1231", "output": "NO"}, {"input": "1a2B2a1", "output": "YES"}, {"input": "abcde", "output": "NO"}, {"input": "Madam, I'm Adam.", "output": "YES"}, {"input": "Z", "output": "YES"}], "raw_generation": []}
{"task_id": "Prolog/0023", "language": "Prolog", "difficulty": "easy", "instruction": "Read a line containing integers separated by commas and/or spaces; print their sum.", "prompt": "Read a line containing integers separated by commas and/or spaces; print their sum.", "mode": "io", "canonical_solution": "```prolog\n:- set_prolog_flag(verbose, silent).\n:- prompt(_, '').\n:- initialization(main, main).\n\nmain :-\n    read_line_to_string(user_input, Line),\n    split_string(Line, \", \", \", \", Parts),\n    maplist(number_string, Numbers, Parts),\n    sum_list(Numbers, Sum),\n    writeln(Sum),\n    halt.\n```", "tests": [{"input": "1 2 3 4 5", "output": "15\n"}, {"input": "10,20,30", "output": "60\n"}, {"input": "7, 8 9,10 11", "output": "45\n"}, {"input": "   5    5,    5     ,5   ", "output": "20\n"}, {"input": "-3, -4 7", "output": "0\n"}, {"input": "42", "output": "42\n"}, {"input": "0,0 0, 0", "output": "0\n"}, {"input": "1000000, 2000000 3000000", "output": "6000000\n"}, {"input": "-10, -20, 15 5 10", "output": "0\n"}, {"input": "1,2 3,4 5,6 7,8 9,10", "output": "55\n"}], "raw_generation": []}
{"task_id": "Prolog/0024", "language": "Prolog", "difficulty": "easy", "instruction": "Given n, print the smallest k such that k! is divisible by n, or -1 if none within 1..12.", "prompt": "Given n, print the smallest k such that k! is divisible by n, or -1 if none within 1..12.", "mode": "io", "canonical_solution": "```prolog\n:- set_prolog_flag(verbose, silent).\n:- initialization(main, main).\n\nfactorial(0, 1).\nfactorial(N, F) :- N > 0, N1 is N - 1, factorial(N1, F1), F is N * F1.\n\nfind_k(N, K) :-\n    between(1, 12, K),\n    factorial(K, F),\n    F mod N =:= 0,\n    !.\nfind_k(_, -1).\n\nmain([]) :-\n    read(N),\n    find_k(N, K),\n    writeln(K),\n    halt.\n```", "tests": [{"input": "1", "output": "1"}, {"input": "2", "output": "2"}, {"input": "6", "output": "3"}, {"input": "12", "output": "4"}, {"input": "9", "output": "6"}, {"input": "14", "output": "7"}, {"input": "256", "output": "10"}, {"input": "4200", "output": "10"}, {"input": "27720", "output": "11"}, {"input": "39916800", "output": "11"}, {"input": "479001600", "output": "12"}, {"input": "1024", "output": "12"}, {"input": "13", "output": "-1"}, {"input": "49", "output": "-1"}], "raw_generation": []}
{"task_id": "Prolog/0025", "language": "Prolog", "difficulty": "easy", "instruction": "Given n, print the sum of the digits of n.", "prompt": "Given n, print the sum of the digits of n.", "mode": "io", "canonical_solution": "```prolog\n:- set_prolog_flag(verbose, silent).\n:- initialization(main, main).\n\nmain :-\n    read_line_to_string(user_input, Line),\n    string_concat(Line, \"\", Str),\n    atom_number(Str, N),\n    abs(N, AbsN),\n    number_codes(AbsN, Codes),\n    sum_digits(Codes, Sum),\n    writeln(Sum),\n    halt.\n\nsum_digits([], 0).\nsum_digits([H|T], Sum) :-\n    sum_digits(T, RestSum),\n    Digit is H - 48,\n    Sum is Digit + RestSum.\n```", "tests": [{"input": "0", "output": "0"}, {"input": "5", "output": "5"}, {"input": "10", "output": "1"}, {"input": "12345", "output": "15"}, {"input": "999999999", "output": "81"}, {"input": "1000000001", "output": "2"}, {"input": "9876543210123456789", "output": "90"}, {"input": "9223372036854775807", "output": "88"}], "raw_generation": []}
