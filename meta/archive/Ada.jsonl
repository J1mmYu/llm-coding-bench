{"task_id": "Ada/0001", "language": "Ada", "difficulty": "easy", "instruction": "Read n, print the sum of 1..n.", "prompt": "Sum 1..n.", "mode": "io", "canonical_solution": "with Ada.Text_IO;                use Ada.Text_IO;\nwith Ada.Integer_Text_IO;       use Ada.Integer_Text_IO;\nwith Ada.Long_Long_Integer_Text_IO; use Ada.Long_Long_Integer_Text_IO;\nprocedure Main is\n   N : Integer; S : Long_Long_Integer;\nbegin\n   Get(N);\n   S := Long_Long_Integer(N) * Long_Long_Integer(N + 1) / 2;\n   Put(S, Width => 0);\n   New_Line;\nend Main;\n", "tests": [{"input": "1\n", "output": "1"}, {"input": "10\n", "output": "55"}]}
{"task_id": "Ada/0002", "language": "Ada", "difficulty": "easy", "instruction": "Read a line and print it reversed.", "prompt": "Reverse a line.", "mode": "io", "canonical_solution": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Characters.Latin_1; use Ada.Characters.Latin_1;\nprocedure Main is\n   Ch  : Character;\n   Buf : String(1..1000);\n   Len : Natural := 0;\nbegin\n   loop\n      exit when End_Of_File;\n      Get(Ch);\n      exit when Ch = LF;\n      Len := Len + 1;\n      Buf(Len) := Ch;\n   end loop;\n   for I in reverse 1..Len loop\n      Put(Buf(I));\n   end loop;\n   New_Line;\nend Main;\n", "tests": [{"input": "abc\n", "output": "cba"}]}
{"task_id": "Ada/0003", "language": "Ada", "difficulty": "hard", "instruction": "Given n (1<=n<=2e5) and an array of n integers, print the length of the longest subarray with sum=0.", "prompt": "Given n (1<=n<=2e5) and an array of n integers, print the length of the longest subarray with sum=0.", "mode": "io", "canonical_solution": "with Ada.Text_IO;\nwith Ada.Containers.Ordered_Maps;\n\nprocedure Solution is\n   package IO renames Ada.Text_IO;\n   package Long_IO is new IO.Integer_IO(Long_Long_Integer);\n   \n   package Sum_Maps is new Ada.Containers.Ordered_Maps\n     (Key_Type     => Long_Long_Integer,\n      Element_Type => Integer);\n   \n   N : Integer;\n   Sum : Long_Long_Integer := 0;\n   Max_Length : Integer := 0;\n   Map : Sum_Maps.Map;\n   Val : Long_Long_Integer;\n   \nbegin\n   Long_IO.Get(N);\n   \n   -- Insert sum 0 at position 0\n   Map.Insert(0, 0);\n   \n   for I in 1 .. N loop\n      Long_IO.Get(Val);\n      Sum := Sum + Val;\n      \n      if Map.Contains(Sum) then\n         declare\n            Prev_Pos : Integer := Map.Element(Sum);\n            Length : Integer := I - Prev_Pos;\n         begin\n            if Length > Max_Length then\n               Max_Length := Length;\n            end if;\n         end;\n      else\n         Map.Insert(Sum, I);\n      end if;\n   end loop;\n   \n   Long_IO.Put(Long_Long_Integer(Max_Length), Width => 0);\n   IO.New_Line;\nend Solution;\n", "tests": [{"input": "1\n0", "output": "1"}, {"input": "1\n5", "output": "0"}, {"input": "2\n1 -1", "output": "2"}, {"input": "5\n1 2 -3 3 -3", "output": "5"}, {"input": "6\n1 2 -2 4 -4 2", "output": "4"}, {"input": "7\n3 -1 -2 5 -3 1 -3", "output": "7"}, {"input": "8\n1 2 3 -3 -2 -1 4 -4", "output": "8"}, {"input": "5\n1 2 3 4 5", "output": "0"}, {"input": "5\n0 0 0 0 0", "output": "5"}, {"input": "10\n6 -1 -3 4 -2 2 4 -4 2 -2", "output": "9"}, {"input": "4\n-1 1 -1 1", "output": "4"}, {"input": "6\n2 -2 2 -2 2 -2", "output": "6"}, {"input": "7\n1 -1 1 -1 2 -2 3", "output": "6"}, {"input": "2\n1000000000 -1000000000", "output": "2"}, {"input": "6\n0 1 2 -3 0 4", "output": "5"}], "raw_generation": []}
{"task_id": "Ada/0004", "language": "Ada", "difficulty": "hard", "instruction": "Read a line and check balanced brackets for ()[]{} with nesting; print YES/NO.", "prompt": "Read a line and check balanced brackets for ()[]{} with nesting; print YES/NO.", "mode": "io", "canonical_solution": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Containers.Vectors;\n\nprocedure Balanced_Brackets is\n   package Char_Vectors is new Ada.Containers.Vectors\n     (Index_Type   => Positive,\n      Element_Type => Character);\n   \n   Stack : Char_Vectors.Vector;\n   Line  : String := Get_Line;\n   Is_Balanced : Boolean := True;\n   \n   function Matches (Open, Close : Character) return Boolean is\n   begin\n      return (Open = '(' and Close = ')') or\n             (Open = '[' and Close = ']') or\n             (Open = '{' and Close = '}');\n   end Matches;\n   \nbegin\n   for C of Line loop\n      if C = '(' or C = '[' or C = '{' then\n         Stack.Append(C);\n      elsif C = ')' or C = ']' or C = '}' then\n         if Stack.Is_Empty then\n            Is_Balanced := False;\n            exit;\n         elsif Matches(Stack.Last_Element, C) then\n            Stack.Delete_Last;\n         else\n            Is_Balanced := False;\n            exit;\n         end if;\n      end if;\n   end loop;\n   \n   if Is_Balanced and Stack.Is_Empty then\n      Put_Line(\"YES\");\n   else\n      Put_Line(\"NO\");\n   end if;\nend Balanced_Brackets;\n", "tests": [{"input": "()", "output": "YES"}, {"input": "([]){}", "output": "YES"}, {"input": "([)]", "output": "NO"}, {"input": "())", "output": "NO"}, {"input": "(((", "output": "NO"}, {"input": "", "output": "YES"}, {"input": "a+(b*[c-{d/e}])", "output": "YES"}, {"input": "abc123", "output": "YES"}, {"input": "}{", "output": "NO"}, {"input": "[](){}", "output": "YES"}, {"input": "[({})](]", "output": "NO"}, {"input": "([{}])()", "output": "YES"}], "raw_generation": []}
{"task_id": "Ada/0005", "language": "Ada", "difficulty": "hard", "instruction": "Read n and n integers; print the length of the longest increasing subsequence (not necessarily contiguous).", "prompt": "Read n and n integers; print the length of the longest increasing subsequence (not necessarily contiguous).", "mode": "io", "canonical_solution": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Containers.Vectors;\n\nprocedure Longest_Increasing_Subsequence is\n   package Int_IO is new Ada.Text_IO.Integer_IO(Integer);\n   use Int_IO;\n   \n   package Int_Vectors is new Ada.Containers.Vectors(Positive, Integer);\n   use Int_Vectors;\n   \n   N : Integer;\n   Arr : Vector;\n   Temp : Integer;\n   \n   function LIS_Length return Integer is\n      Tails : Vector;\n      Pos : Integer;\n      Left, Right, Mid : Integer;\n   begin\n      if Is_Empty(Arr) then\n         return 0;\n      end if;\n      \n      for I in First_Index(Arr) .. Last_Index(Arr) loop\n         Temp := Element(Arr, I);\n         \n         if Is_Empty(Tails) or else Temp > Last_Element(Tails) then\n            Append(Tails, Temp);\n         else\n            Left := First_Index(Tails);\n            Right := Last_Index(Tails);\n            Pos := Left;\n            \n            while Left <= Right loop\n               Mid := Left + (Right - Left) / 2;\n               if Element(Tails, Mid) < Temp then\n                  Left := Mid + 1;\n               else\n                  Pos := Mid;\n                  Right := Mid - 1;\n               end if;\n            end loop;\n            \n            Replace_Element(Tails, Pos, Temp);\n         end if;\n      end loop;\n      \n      return Integer(Length(Tails));\n   end LIS_Length;\n   \nbegin\n   Get(N);\n   \n   for I in 1 .. N loop\n      Get(Temp);\n      Append(Arr, Temp);\n   end loop;\n   \n   Put(LIS_Length, Width => 1);\n   New_Line;\nend Longest_Increasing_Subsequence;\n", "tests": [{"input": "0", "output": "0"}, {"input": "1\n5", "output": "1"}, {"input": "5\n1 2 3 4 5", "output": "5"}, {"input": "5\n5\n4\n3\n2\n1", "output": "1"}, {"input": "8\n10 9 2 5 3 7 101 18", "output": "4"}, {"input": "8\n2 2 2 2 2 2 2 2", "output": "1"}, {"input": "8\n-1 -2 0 -3 4 -1 2 3", "output": "4"}, {"input": "10\n1 3 5 4 7 0 6 2 2 8", "output": "5"}, {"input": "6\n1000000000 1 1000000000 2 1000000000 3", "output": "3"}, {"input": "7\n3 4 -1 0 6 2 3", "output": "4"}], "raw_generation": []}
{"task_id": "Ada/0006", "language": "Ada", "difficulty": "hard", "instruction": "Read a CSV line with quotes and commas; parse fields and print field count. Quotes may contain commas and escaped quotes \"\".", "prompt": "Read a CSV line with quotes and commas; parse fields and print field count. Quotes may contain commas and escaped quotes \"\".", "mode": "io", "canonical_solution": "with Ada.Text_IO;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\nprocedure CSV_Parser is\n   Line : String (1 .. 10000);\n   Last : Natural;\n   Field_Count : Natural := 0;\n   I : Positive := 1;\n   In_Quotes : Boolean := False;\n   Ch : Character;\nbegin\n   Ada.Text_IO.Get_Line (Line, Last);\n   \n   if Last = 0 then\n      Ada.Text_IO.Put_Line (\"0\");\n      return;\n   end if;\n   \n   Field_Count := 1;\n   \n   while I <= Last loop\n      Ch := Line (I);\n      \n      if In_Quotes then\n         if Ch = '\"' then\n            if I < Last and then Line (I + 1) = '\"' then\n               -- Escaped quote \"\"\n               I := I + 1;\n            else\n               -- End of quoted field\n               In_Quotes := False;\n            end if;\n         end if;\n      else\n         if Ch = '\"' then\n            In_Quotes := True;\n         elsif Ch = ',' then\n            Field_Count := Field_Count + 1;\n         end if;\n      end if;\n      \n      I := I + 1;\n   end loop;\n   \n   Ada.Text_IO.Put_Line (Natural'Image (Field_Count));\nend CSV_Parser;\n", "tests": [{"input": "a,b,c", "output": "3"}, {"input": "\"a,b\",c", "output": "2"}, {"input": "\"He said \"\"Hello, World!\"\"\"", "output": "1"}, {"input": ",", "output": "2"}, {"input": ",,,", "output": "4"}, {"input": "a,b,", "output": "3"}, {"input": ",a,b", "output": "3"}, {"input": "\"\"", "output": "1"}, {"input": "\"\",\"\",", "output": "3"}, {"input": "\"a\"\"b\",\"c,d\",e", "output": "3"}, {"input": "\"Name: \"\"Doe, John\"\"\",Age", "output": "2"}, {"input": "\"one, \"\"two\"\" and three\",4", "output": "2"}], "raw_generation": []}
{"task_id": "Ada/0007", "language": "Ada", "difficulty": "hard", "instruction": "Read a string s and integer k; print the lexicographically smallest substring of length k.", "prompt": "Read a string s and integer k; print the lexicographically smallest substring of length k.", "mode": "io", "canonical_solution": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\nprocedure Main is\n   S : Unbounded_String;\n   K : Integer;\n   Min_Sub : Unbounded_String;\n   Current_Sub : Unbounded_String;\n   S_Str : String(1..1000);\n   S_Last : Natural;\nbegin\n   Get_Line(S_Str, S_Last);\n   S := To_Unbounded_String(S_Str(1..S_Last));\n   Get(K);\n   \n   Min_Sub := To_Unbounded_String(Slice(S, 1, K));\n   \n   for I in 2 .. Length(S) - K + 1 loop\n      Current_Sub := To_Unbounded_String(Slice(S, I, I + K - 1));\n      if Current_Sub < Min_Sub then\n         Min_Sub := Current_Sub;\n      end if;\n   end loop;\n   \n   Put_Line(To_String(Min_Sub));\nend Main;\n", "tests": [{"input": "banana\n3", "output": "ana"}, {"input": "leetcode\n1", "output": "c"}, {"input": "abc\n3", "output": "abc"}, {"input": "aaaaa\n3", "output": "aaa"}, {"input": "zyxwv\n2", "output": "wv"}, {"input": "cbabcab\n3", "output": "abc"}, {"input": "ababa\n2", "output": "ab"}, {"input": "a\n1", "output": "a"}, {"input": "kjihgfedcba\n4", "output": "dcba"}, {"input": "bbaaa\n2", "output": "aa"}], "raw_generation": []}
{"task_id": "Ada/0008", "language": "Ada", "difficulty": "hard", "instruction": "Read n and then n intervals [l,r]; merge and output total covered length.", "prompt": "Read n and then n intervals [l,r]; merge and output total covered length.", "mode": "io", "canonical_solution": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Containers.Vectors;\n\nprocedure Main is\n   type Interval is record\n      L, R : Integer;\n   end record;\n   \n   package Interval_Vectors is new Ada.Containers.Vectors\n     (Index_Type   => Natural,\n      Element_Type => Interval);\n   use Interval_Vectors;\n   \n   N : Integer;\n   Intervals : Vector;\n   \n   procedure Sort_Intervals (V : in out Vector) is\n      Temp : Interval;\n      Min_Idx : Natural;\n   begin\n      for I in 0 .. Natural(V.Length) - 1 loop\n         Min_Idx := I;\n         for J in I + 1 .. Natural(V.Length) - 1 loop\n            if V(J).L < V(Min_Idx).L then\n               Min_Idx := J;\n            end if;\n         end loop;\n         if Min_Idx /= I then\n            Temp := V(I);\n            V(I) := V(Min_Idx);\n            V(Min_Idx) := Temp;\n         end if;\n      end loop;\n   end Sort_Intervals;\n   \n   L, R : Integer;\n   Total_Length : Integer := 0;\n   Current_L, Current_R : Integer;\n   \nbegin\n   N := Integer'Value(Get_Line);\n   \n   for I in 1 .. N loop\n      declare\n         Line : String := Get_Line;\n         Space_Pos : Natural := 0;\n      begin\n         for J in Line'Range loop\n            if Line(J) = ' ' then\n               Space_Pos := J;\n               exit;\n            end if;\n         end loop;\n         L := Integer'Value(Line(Line'First .. Space_Pos - 1));\n         R := Integer'Value(Line(Space_Pos + 1 .. Line'Last));\n         Intervals.Append((L, R));\n      end;\n   end loop;\n   \n   Sort_Intervals(Intervals);\n   \n   if Natural(Intervals.Length) > 0 then\n      Current_L := Intervals(0).L;\n      Current_R := Intervals(0).R;\n      \n      for I in 1 .. Natural(Intervals.Length) - 1 loop\n         if Intervals(I).L <= Current_R then\n            if Intervals(I).R > Current_R then\n               Current_R := Intervals(I).R;\n            end if;\n         else\n            Total_Length := Total_Length + (Current_R - Current_L);\n            Current_L := Intervals(I).L;\n            Current_R := Intervals(I).R;\n         end if;\n      end loop;\n      \n      Total_Length := Total_Length + (Current_R - Current_L);\n   end if;\n   \n   Put_Line(Integer'Image(Total_Length));\nend Main;\n", "tests": [{"input": "2\n1 5\n3 7\n", "output": "6"}, {"input": "2\n1 2\n4 6\n", "output": "3"}, {"input": "3\n0 1\n1 2\n2 2\n", "output": "2"}, {"input": "2\n-5 -1\n-2 3\n", "output": "8"}, {"input": "3\n2 10\n3 5\n1 3\n", "output": "9"}, {"input": "2\n0 1000000000\n1000000000 2000000000\n", "output": "2000000000"}, {"input": "3\n5 6\n1 2\n3 4\n", "output": "3"}, {"input": "6\n1 2\n2 3\n5 7\n6 6\n7 8\n10 10\n", "output": "5"}, {"input": "5\n0 0\n-1 0\n0 1\n2 2\n1 2\n", "output": "3"}, {"input": "4\n-10 -8\n-7 -5\n-6 -6\n-3 -1\n", "output": "6"}, {"input": "1\n42 42\n", "output": "0"}, {"input": "0\n", "output": "0"}], "raw_generation": []}
{"task_id": "Ada/0009", "language": "Ada", "difficulty": "hard", "instruction": "Read a string; print 1 if it is a valid IPv4 address, else 0.", "prompt": "Read a string; print 1 if it is a valid IPv4 address, else 0.", "mode": "io", "canonical_solution": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Strings.Fixed; use Ada.Strings.Fixed;\nwith Ada.Strings; use Ada.Strings;\n\nprocedure Main is\n   Input : String := Get_Line;\n   Dot_Count : Natural := 0;\n   Start_Pos : Positive := 1;\n   Valid : Boolean := True;\n   \n   function Is_Valid_Octet (S : String) return Boolean is\n      Num : Integer;\n   begin\n      if S'Length = 0 or S'Length > 3 then\n         return False;\n      end if;\n      \n      -- Check all characters are digits\n      for I in S'Range loop\n         if S(I) < '0' or S(I) > '9' then\n            return False;\n         end if;\n      end loop;\n      \n      -- Check for leading zeros (except \"0\" itself)\n      if S'Length > 1 and then S(S'First) = '0' then\n         return False;\n      end if;\n      \n      -- Check range 0-255\n      Num := Integer'Value(S);\n      return Num >= 0 and Num <= 255;\n   exception\n      when others =>\n         return False;\n   end Is_Valid_Octet;\n   \nbegin\n   if Input'Length = 0 then\n      Put_Line(\"0\");\n      return;\n   end if;\n   \n   -- Count dots and validate octets\n   for I in Input'Range loop\n      if Input(I) = '.' then\n         Dot_Count := Dot_Count + 1;\n         if Dot_Count > 3 then\n            Valid := False;\n            exit;\n         end if;\n         \n         if not Is_Valid_Octet(Input(Start_Pos .. I - 1)) then\n            Valid := False;\n            exit;\n         end if;\n         \n         Start_Pos := I + 1;\n      end if;\n   end loop;\n   \n   -- Check last octet and dot count\n   if Valid and Dot_Count = 3 then\n      Valid := Is_Valid_Octet(Input(Start_Pos .. Input'Last));\n   else\n      Valid := False;\n   end if;\n   \n   if Valid then\n      Put_Line(\"1\");\n   else\n      Put_Line(\"0\");\n   end if;\nend Main;\n", "tests": [{"input": "192.168.1.1", "output": "1"}, {"input": "255.255.255.255", "output": "1"}, {"input": "256.100.100.100", "output": "0"}, {"input": "192.168.01.1", "output": "0"}, {"input": "0.0.0.0", "output": "1"}, {"input": "1.2.3", "output": "0"}, {"input": "1.2.3.4.5", "output": "0"}, {"input": "1..2.3", "output": "0"}, {"input": "abc.def.ghi.jkl", "output": "0"}, {"input": " 1.2.3.4", "output": "0"}, {"input": "1.2.3.4 ", "output": "0"}, {"input": "01.0.0.0", "output": "0"}, {"input": "10.0.-1.0", "output": "0"}, {"input": "1.2.3.a", "output": "0"}, {"input": "123.45.67.89", "output": "1"}, {"input": "1.1.1.1.", "output": "0"}, {"input": ".1.1.1.1", "output": "0"}, {"input": "0.10.0.0", "output": "1"}, {"input": "123.456.78.90", "output": "0"}, {"input": "00.0.0.0", "output": "0"}, {"input": "+1.2.3.4", "output": "0"}, {"input": "1.01.1.1", "output": "0"}, {"input": "2.5.5.255", "output": "1"}, {"input": "...", "output": "0"}, {"input": "", "output": "0"}], "raw_generation": []}
{"task_id": "Ada/0010", "language": "Ada", "difficulty": "hard", "instruction": "Read a line; print word frequencies sorted by (-count, word).", "prompt": "Read a line; print word frequencies sorted by (-count, word).", "mode": "io", "canonical_solution": "with Ada.Text_IO;\nwith Ada.Strings.Unbounded;\nwith Ada.Containers.Vectors;\nwith Ada.Containers.Indefinite_Hashed_Maps;\nwith Ada.Strings.Hash;\n\nprocedure Word_Frequency is\n   use Ada.Text_IO;\n   use Ada.Strings.Unbounded;\n\n   package String_Integer_Maps is new Ada.Containers.Indefinite_Hashed_Maps\n     (Key_Type        => String,\n      Element_Type    => Integer,\n      Hash            => Ada.Strings.Hash,\n      Equivalent_Keys => \"=\");\n\n   type Word_Count is record\n      Word  : Unbounded_String;\n      Count : Integer;\n   end record;\n\n   package Word_Count_Vectors is new Ada.Containers.Vectors\n     (Index_Type   => Positive,\n      Element_Type => Word_Count);\n\n   function Less_Than (Left, Right : Word_Count) return Boolean is\n   begin\n      if Left.Count /= Right.Count then\n         return Left.Count > Right.Count;  -- Sort by -count (descending)\n      else\n         return To_String (Left.Word) < To_String (Right.Word);  -- Then by word\n      end if;\n   end Less_Than;\n\n   package Word_Count_Sorting is new Word_Count_Vectors.Generic_Sorting (\"<\" => Less_Than);\n\n   Line   : String := Get_Line;\n   Map    : String_Integer_Maps.Map;\n   Vec    : Word_Count_Vectors.Vector;\n   I      : Positive := Line'First;\n   J      : Positive;\n   Word   : Unbounded_String;\n\nbegin\n   -- Parse words\n   while I <= Line'Last loop\n      -- Skip non-alphabetic characters\n      while I <= Line'Last and then not (Line (I) in 'A' .. 'Z' | 'a' .. 'z') loop\n         I := I + 1;\n      end loop;\n\n      if I <= Line'Last then\n         J := I;\n         while J <= Line'Last and then (Line (J) in 'A' .. 'Z' | 'a' .. 'z') loop\n            J := J + 1;\n         end loop;\n\n         Word := To_Unbounded_String (Line (I .. J - 1));\n         \n         if Map.Contains (To_String (Word)) then\n            Map (To_String (Word)) := Map (To_String (Word)) + 1;\n         else\n            Map.Insert (To_String (Word), 1);\n         end if;\n\n         I := J;\n      end if;\n   end loop;\n\n   -- Convert map to vector\n   for C in Map.Iterate loop\n      Vec.Append (Word_Count'(Word  => To_Unbounded_String (String_Integer_Maps.Key (C)),\n                              Count => String_Integer_Maps.Element (C)));\n   end loop;\n\n   -- Sort\n   Word_Count_Sorting.Sort (Vec);\n\n   -- Print\n   for WC of Vec loop\n      Put_Line (To_String (WC.Word) & \" \" & Integer'Image (WC.Count)(2 .. Integer'Image (WC.Count)'Last));\n   end loop;\nend Word_Frequency;\n", "tests": [{"input": "to be or not to be", "output": "be 2\nto 2\nnot 1\nor 1"}, {"input": "hello", "output": "hello 1"}, {"input": "", "output": ""}, {"input": "a   b\ta a", "output": "a 3\nb 1"}, {"input": "Apple apple banana Banana apple", "output": "apple 2\nApple 1\nBanana 1\nbanana 1"}, {"input": "10 2 2 x z y 10", "output": "10 2\n2 2\nx 1\ny 1\nz 1"}, {"input": "  foo   foo bar   ", "output": "foo 2\nbar 1"}, {"input": "go go GO Go go", "output": "go 3\nGO 1\nGo 1"}], "raw_generation": []}
{"task_id": "Ada/0011", "language": "Ada", "difficulty": "hard", "instruction": "Given n,m and a grid of '.' and '#', count connected components (4-direction).", "prompt": "Given n,m and a grid of '.' and '#', count connected components (4-direction).", "mode": "io", "canonical_solution": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Containers.Vectors;\n\nprocedure Main is\n   N, M : Integer;\n   type Grid_Type is array (Positive range <>, Positive range <>) of Character;\n   type Visited_Type is array (Positive range <>, Positive range <>) of Boolean;\n   \n   procedure DFS (Grid : Grid_Type; Visited : in out Visited_Type; I, J : Integer) is\n      DI : array (1..4) of Integer := (0, 0, 1, -1);\n      DJ : array (1..4) of Integer := (1, -1, 0, 0);\n      NI, NJ : Integer;\n   begin\n      Visited(I, J) := True;\n      for K in 1..4 loop\n         NI := I + DI(K);\n         NJ := J + DJ(K);\n         if NI >= 1 and NI <= N and NJ >= 1 and NJ <= M then\n            if Grid(NI, NJ) = '.' and not Visited(NI, NJ) then\n               DFS(Grid, Visited, NI, NJ);\n            end if;\n         end if;\n      end loop;\n   end DFS;\n   \nbegin\n   Get(N);\n   Get(M);\n   Skip_Line;\n   \n   declare\n      Grid : Grid_Type(1..N, 1..M);\n      Visited : Visited_Type(1..N, 1..M) := (others => (others => False));\n      Count : Integer := 0;\n      Line : String(1..M);\n   begin\n      for I in 1..N loop\n         Get_Line(Line, M);\n         for J in 1..M loop\n            Grid(I, J) := Line(J);\n         end loop;\n      end loop;\n      \n      for I in 1..N loop\n         for J in 1..M loop\n            if Grid(I, J) = '.' and not Visited(I, J) then\n               DFS(Grid, Visited, I, J);\n               Count := Count + 1;\n            end if;\n         end loop;\n      end loop;\n      \n      Put_Line(Integer'Image(Count));\n   end;\nend Main;\n", "tests": [{"input": "1 1\n.\n", "output": "0"}, {"input": "1 1\n#\n", "output": "1"}, {"input": "2 2\n##\n##\n", "output": "1"}, {"input": "3 3\n#.#\n.#.\n#.#\n", "output": "5"}, {"input": "4 4\n##..\n.#..\n..#.\n..##\n", "output": "2"}, {"input": "5 5\n#####\n#...#\n#.#.#\n#...#\n#####\n", "output": "2"}, {"input": "2 3\n...\n...\n", "output": "0"}, {"input": "1 5\n#.#.#\n", "output": "3"}, {"input": "5 1\n#\n.\n#\n#\n.\n", "output": "2"}, {"input": "3 5\n#..##\n.##..\n#..#.\n", "output": "5"}, {"input": "4 5\n#.#..\n##..#\n..#.#\n..##.\n", "output": "4"}, {"input": "2 5\n##..#\n#..##\n", "output": "2"}], "raw_generation": []}
{"task_id": "Ada/0012", "language": "Ada", "difficulty": "hard", "instruction": "Read a line; run-length encode (RLE) it as <char><count> without separators.", "prompt": "Read a line; run-length encode (RLE) it as <char><count> without separators.", "mode": "io", "canonical_solution": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\nprocedure RLE is\n   Line : String := Get_Line;\n   Count : Natural := 1;\nbegin\n   if Line'Length = 0 then\n      return;\n   end if;\n   \n   for I in Line'First + 1 .. Line'Last loop\n      if Line(I) = Line(I - 1) then\n         Count := Count + 1;\n      else\n         Put(Line(I - 1) & Natural'Image(Count)(2 .. Natural'Image(Count)'Last));\n         Count := 1;\n      end if;\n   end loop;\n   \n   Put(Line(Line'Last) & Natural'Image(Count)(2 .. Natural'Image(Count)'Last));\n   New_Line;\nend RLE;\n", "tests": [{"input": "aaabccc", "output": "a3b1c3"}, {"input": "Z", "output": "Z1"}, {"input": "AAaa", "output": "A2a2"}, {"input": "111223", "output": "132231"}, {"input": "a   b", "output": "a1 3b1"}, {"input": "!!!??", "output": "!3?2"}, {"input": "bbbbbbbbbb", "output": "b10"}, {"input": "", "output": ""}, {"input": "\t\t\ta", "output": "\t3a1"}, {"input": "ABCD", "output": "A1B1C1D1"}], "raw_generation": []}
{"task_id": "Ada/0013", "language": "Ada", "difficulty": "hard", "instruction": "Read two big integers (up to 10^500) as strings; print their sum.", "prompt": "Read two big integers (up to 10^500) as strings; print their sum.", "mode": "io", "canonical_solution": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\nprocedure Big_Int_Sum is\n   function Add_Big_Integers(A, B : String) return String is\n      Len_A : constant Natural := A'Length;\n      Len_B : constant Natural := B'Length;\n      Max_Len : constant Natural := Natural'Max(Len_A, Len_B);\n      Result : String(1 .. Max_Len + 1) := (others => '0');\n      Carry : Natural := 0;\n      Digit_A, Digit_B, Sum : Natural;\n      Pos : Natural := Max_Len + 1;\n   begin\n      for I in 0 .. Max_Len - 1 loop\n         if I < Len_A then\n            Digit_A := Character'Pos(A(Len_A - I)) - Character'Pos('0');\n         else\n            Digit_A := 0;\n         end if;\n         \n         if I < Len_B then\n            Digit_B := Character'Pos(B(Len_B - I)) - Character'Pos('0');\n         else\n            Digit_B := 0;\n         end if;\n         \n         Sum := Digit_A + Digit_B + Carry;\n         Result(Pos) := Character'Val(Character'Pos('0') + (Sum mod 10));\n         Carry := Sum / 10;\n         Pos := Pos - 1;\n      end loop;\n      \n      if Carry > 0 then\n         Result(1) := Character'Val(Character'Pos('0') + Carry);\n         return Result;\n      else\n         return Result(2 .. Result'Last);\n      end if;\n   end Add_Big_Integers;\n   \n   A_Str, B_Str : Unbounded_String;\nbegin\n   A_Str := To_Unbounded_String(Get_Line);\n   B_Str := To_Unbounded_String(Get_Line);\n   Put_Line(Add_Big_Integers(To_String(A_Str), To_String(B_Str)));\nend Big_Int_Sum;\n", "tests": [{"input": "123\n456", "output": "579"}, {"input": "999\n1", "output": "1000"}, {"input": "12345\n678", "output": "13023"}, {"input": "0\n12345678901234567890", "output": "12345678901234567890"}, {"input": "0000123\n0000077", "output": "200"}, {"input": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n1", "output": "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"input": "1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\n8765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109", "output": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"input": "10000000000000000000\n90000000000000000000", "output": "100000000000000000000"}, {"input": "987654321098765432109876543210\n12345678901234567890", "output": "987654321111111111011111111100"}, {"input": "000000000000000000000000000000000000000000042\n000000000000000000000000000000000000000000058", "output": "100"}], "raw_generation": []}
{"task_id": "Ada/0014", "language": "Ada", "difficulty": "hard", "instruction": "Given n,m and edges (1-indexed), output a topological ordering or print -1 if cycle.", "prompt": "Given n,m and edges (1-indexed), output a topological ordering or print -1 if cycle.", "mode": "io", "canonical_solution": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Containers.Vectors;\n\nprocedure Topological_Sort is\n   N, M : Integer;\n   \n   package Integer_Vectors is new Ada.Containers.Vectors\n     (Index_Type   => Natural,\n      Element_Type => Integer);\n   use Integer_Vectors;\n   \n   type Adjacency_List is array (Integer range <>) of Integer_Vectors.Vector;\n   type Integer_Array is array (Integer range <>) of Integer;\n   \n   function Solve return Boolean is\n      Adj : Adjacency_List (1 .. N);\n      In_Degree : Integer_Array (1 .. N) := (others => 0);\n      Queue : Integer_Vectors.Vector;\n      Result : Integer_Vectors.Vector;\n      U, V : Integer;\n   begin\n      for I in 1 .. M loop\n         Get (U);\n         Get (V);\n         Adj (U).Append (V);\n         In_Degree (V) := In_Degree (V) + 1;\n      end loop;\n      \n      for I in 1 .. N loop\n         if In_Degree (I) = 0 then\n            Queue.Append (I);\n         end if;\n      end loop;\n      \n      while not Queue.Is_Empty loop\n         declare\n            Current : constant Integer := Queue.First_Element;\n         begin\n            Queue.Delete_First;\n            Result.Append (Current);\n            \n            for I in Adj (Current).First_Index .. Adj (Current).Last_Index loop\n               declare\n                  Neighbor : constant Integer := Adj (Current).Element (I);\n               begin\n                  In_Degree (Neighbor) := In_Degree (Neighbor) - 1;\n                  if In_Degree (Neighbor) = 0 then\n                     Queue.Append (Neighbor);\n                  end if;\n               end;\n            end loop;\n         end;\n      end loop;\n      \n      if Integer (Result.Length) /= N then\n         return False;\n      end if;\n      \n      for I in Result.First_Index .. Result.Last_Index loop\n         if I > 0 then\n            Put (\" \");\n         end if;\n         Put (Integer'Image (Result.Element (I))(2 .. Integer'Image (Result.Element (I))'Last));\n      end loop;\n      New_Line;\n      return True;\n   end Solve;\n   \nbegin\n   Get (N);\n   Get (M);\n   \n   if not Solve then\n      Put_Line (\"-1\");\n   end if;\nend Topological_Sort;\n", "tests": [{"input": "1 0", "output": "1"}, {"input": "2 1\n1 2", "output": "1 2"}, {"input": "3 3\n1 2\n2 3\n1 3", "output": "1 2 3"}, {"input": "3 3\n2 1\n1 3\n2 3", "output": "2 1 3"}, {"input": "3 3\n1 2\n2 3\n3 1", "output": "-1"}, {"input": "3 1\n2 2", "output": "-1"}, {"input": "3 3\n1 2\n1 2\n2 3", "output": "1 2 3"}, {"input": "5 7\n1 2\n2 3\n3 4\n4 5\n1 3\n2 4\n1 4", "output": "1 2 3 4 5"}, {"input": "4 4\n1 2\n2 3\n3 1\n3 4", "output": "-1"}], "raw_generation": []}
{"task_id": "Ada/0015", "language": "Ada", "difficulty": "hard", "instruction": "Read multiple lines until EOF; output the line with the maximum number of distinct characters (break ties by earliest).", "prompt": "Read multiple lines until EOF; output the line with the maximum number of distinct characters (break ties by earliest).", "mode": "io", "canonical_solution": "with Ada.Text_IO;\nwith Ada.Strings.Unbounded;\n\nprocedure Max_Distinct is\n   use Ada.Text_IO;\n   use Ada.Strings.Unbounded;\n   \n   function Count_Distinct(S : String) return Natural is\n      Seen : array (Character) of Boolean := (others => False);\n      Count : Natural := 0;\n   begin\n      for I in S'Range loop\n         if not Seen(S(I)) then\n            Seen(S(I)) := True;\n            Count := Count + 1;\n         end if;\n      end loop;\n      return Count;\n   end Count_Distinct;\n   \n   Max_Line : Unbounded_String := Null_Unbounded_String;\n   Max_Count : Natural := 0;\n   Current_Line : Unbounded_String;\n   \nbegin\n   while not End_Of_File loop\n      Current_Line := To_Unbounded_String(Get_Line);\n      declare\n         Current_Count : constant Natural := Count_Distinct(To_String(Current_Line));\n      begin\n         if Current_Count > Max_Count then\n            Max_Count := Current_Count;\n            Max_Line := Current_Line;\n         end if;\n      end;\n   end loop;\n   \n   Put_Line(To_String(Max_Line));\nend Max_Distinct;\n", "tests": [{"input": "hello\nworld\nabcdef", "output": "abcdef"}, {"input": "aa\nab\nbc", "output": "ab"}, {"input": "!!!\n , \nabc def\nabcd!abcd?", "output": "abc def"}, {"input": "zzz", "output": "zzz"}, {"input": "\na\n\n ", "output": "a"}, {"input": "AaAa\nAabc\naAbB", "output": "Aabc"}, {"input": "abcde\npackmyboxwithfivedozenliquorjugs\nabcdefghijklmnopqrstuvwxyz", "output": "packmyboxwithfivedozenliquorjugs"}, {"input": "\t\t\n \t \na\tb\tc\nabc", "output": "a\tb\tc"}], "raw_generation": []}
{"task_id": "Ada/0016", "language": "Ada", "difficulty": "hard", "instruction": "Read a line; evaluate a simple expression with + - * / and parentheses (integers, no unary minus), print result.", "prompt": "Read a line; evaluate a simple expression with + - * / and parentheses (integers, no unary minus), print result.", "mode": "io", "canonical_solution": "with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\nprocedure Main is\n   Input : String := Get_Line;\n   Pos : Integer := 1;\n\n   function Parse_Expression return Integer;\n\n   function Skip_Spaces is\n   begin\n      while Pos <= Input'Length and then Input(Pos) = ' ' loop\n         Pos := Pos + 1;\n      end loop;\n   end Skip_Spaces;\n\n   function Parse_Number return Integer is\n      Result : Integer := 0;\n   begin\n      Skip_Spaces;\n      while Pos <= Input'Length and then Input(Pos) in '0'..'9' loop\n         Result := Result * 10 + (Character'Pos(Input(Pos)) - Character'Pos('0'));\n         Pos := Pos + 1;\n      end loop;\n      return Result;\n   end Parse_Number;\n\n   function Parse_Factor return Integer is\n      Result : Integer;\n   begin\n      Skip_Spaces;\n      if Pos <= Input'Length and then Input(Pos) = '(' then\n         Pos := Pos + 1;\n         Result := Parse_Expression;\n         Skip_Spaces;\n         if Pos <= Input'Length and then Input(Pos) = ')' then\n            Pos := Pos + 1;\n         end if;\n         return Result;\n      else\n         return Parse_Number;\n      end if;\n   end Parse_Factor;\n\n   function Parse_Term return Integer is\n      Result : Integer := Parse_Factor;\n      Op : Character;\n   begin\n      loop\n         Skip_Spaces;\n         exit when Pos > Input'Length or else (Input(Pos) /= '*' and Input(Pos) /= '/');\n         Op := Input(Pos);\n         Pos := Pos + 1;\n         if Op = '*' then\n            Result := Result * Parse_Factor;\n         else\n            Result := Result / Parse_Factor;\n         end if;\n      end loop;\n      return Result;\n   end Parse_Term;\n\n   function Parse_Expression return Integer is\n      Result : Integer := Parse_Term;\n      Op : Character;\n   begin\n      loop\n         Skip_Spaces;\n         exit when Pos > Input'Length or else (Input(Pos) /= '+' and Input(Pos) /= '-');\n         Op := Input(Pos);\n         Pos := Pos + 1;\n         if Op = '+' then\n            Result := Result + Parse_Term;\n         else\n            Result := Result - Parse_Term;\n         end if;\n      end loop;\n      return Result;\n   end Parse_Expression;\n\nbegin\n   Put_Line(Integer'Image(Parse_Expression));\nend Main;\n", "tests": [{"input": "2+3", "output": "5"}, {"input": "  7 *  8 ", "output": "56"}, {"input": "2+3*4", "output": "14"}, {"input": "(2+3)*4", "output": "20"}, {"input": "((1+2)*(3+(4*5)))", "output": "69"}, {"input": "20/5+6", "output": "10"}, {"input": "(18/(3*3))+2", "output": "4"}, {"input": "10-3-2", "output": "5"}, {"input": "100/(5+5)*(3+1)", "output": "40"}, {"input": "0*123+(45-45)", "output": "0"}, {"input": "1+2-3+4-5+6", "output": "5"}, {"input": "3*(4/2+5)", "output": "21"}], "raw_generation": []}
{"task_id": "Ada/0017", "language": "Ada", "difficulty": "hard", "instruction": "Read string s; print length of the longest substring without repeating characters.", "prompt": "Read string s; print length of the longest substring without repeating characters.", "mode": "io", "canonical_solution": "with Ada.Text_IO;\nwith Ada.Strings.Unbounded;\n\nprocedure Main is\n   use Ada.Text_IO;\n   use Ada.Strings.Unbounded;\n   \n   S : Unbounded_String;\n   Max_Length : Natural := 0;\nbegin\n   S := To_Unbounded_String(Get_Line);\n   \n   declare\n      Str : constant String := To_String(S);\n      N : constant Natural := Str'Length;\n   begin\n      for I in Str'Range loop\n         declare\n            Seen : array (Character) of Boolean := (others => False);\n            Length : Natural := 0;\n         begin\n            for J in I .. Str'Last loop\n               if Seen(Str(J)) then\n                  exit;\n               end if;\n               Seen(Str(J)) := True;\n               Length := Length + 1;\n            end loop;\n            \n            if Length > Max_Length then\n               Max_Length := Length;\n            end if;\n         end;\n      end loop;\n   end;\n   \n   Put_Line(Natural'Image(Max_Length)(2 .. Natural'Image(Max_Length)'Last));\nend Main;\n", "tests": [{"input": "", "output": "0"}, {"input": "a", "output": "1"}, {"input": "aa", "output": "1"}, {"input": "ab", "output": "2"}, {"input": "abcabcbb", "output": "3"}, {"input": "bbbbb", "output": "1"}, {"input": "pwwkew", "output": "3"}, {"input": "dvdf", "output": "3"}, {"input": "abba", "output": "2"}, {"input": "tmmzuxt", "output": "5"}, {"input": "abc def ghi", "output": "7"}, {"input": "123451234", "output": "5"}, {"input": "aAaA", "output": "2"}, {"input": " ", "output": "1"}, {"input": "abcddef", "output": "4"}, {"input": "qrsvbspk", "output": "5"}, {"input": "anviaj", "output": "5"}, {"input": "thequickbrownfox", "output": "14"}, {"input": "a1b2c3a4", "output": "7"}, {"input": "abcdefghijklmnopqrstuvwxyz", "output": "26"}], "raw_generation": []}
