{"task_id": "Fortran/0001", "language": "Fortran", "difficulty": "easy", "instruction": "Read n, output the sum of 1..n.", "prompt": "Sum 1..n.", "mode": "io", "canonical_solution": "program sum_n\n  implicit none\n  integer :: n\n  integer(kind=8) :: s\n  read(*,*) n\n  s = int(n,8)*(int(n,8)+1)/2\n  print '(I0)', s\nend program\n", "tests": [{"input": "1\n", "output": "1"}, {"input": "10\n", "output": "55"}, {"input": "100\n", "output": "5050"}]}
{"task_id": "Fortran/0002", "language": "Fortran", "difficulty": "easy", "instruction": "Read one line and print its reverse.", "prompt": "Reverse a line.", "mode": "io", "canonical_solution": "program rev\n  implicit none\n  character(len=1000) :: s\n  integer :: i, n\n  s = ''\n  read(*,'(A)') s\n  n = len_trim(s)\n  do i = n,1,-1\n     write(*,'(A)',advance='no') s(i:i)\n  end do\n  write(*,*)\nend program\n", "tests": [{"input": "abc\n", "output": "cba"}, {"input": "x\n", "output": "x"}]}
{"task_id": "Fortran/0003", "language": "Fortran", "difficulty": "hard", "instruction": "Given n (1<=n<=2e5) and an array of n integers, print the length of the longest subarray with sum=0.", "prompt": "Given n (1<=n<=2e5) and an array of n integers, print the length of the longest subarray with sum=0.", "mode": "io", "canonical_solution": "program longest_subarray\n    implicit none\n    integer :: n, i, j, max_len\n    integer, allocatable :: arr(:)\n    integer(kind=8) :: sum\n    integer(kind=8), allocatable :: prefix(:)\n    integer, allocatable :: first_occurrence(:)\n    integer :: min_idx, max_idx\n    integer(kind=8) :: min_sum, max_sum\n    \n    read*, n\n    allocate(arr(n))\n    allocate(prefix(0:n))\n    \n    do i = 1, n\n        read*, arr(i)\n    end do\n    \n    ! Calculate prefix sums\n    prefix(0) = 0\n    do i = 1, n\n        prefix(i) = prefix(i-1) + arr(i)\n    end do\n    \n    ! Find min and max prefix sums to determine hash table size\n    min_sum = minval(prefix)\n    max_sum = maxval(prefix)\n    \n    min_idx = int(min_sum)\n    max_idx = int(max_sum)\n    \n    allocate(first_occurrence(min_idx:max_idx))\n    first_occurrence = -1\n    \n    max_len = 0\n    \n    do i = 0, n\n        sum = prefix(i)\n        if (first_occurrence(int(sum)) == -1) then\n            first_occurrence(int(sum)) = i\n        else\n            max_len = max(max_len, i - first_occurrence(int(sum)))\n        end if\n    end do\n    \n    print*, max_len\n    \n    deallocate(arr)\n    deallocate(prefix)\n    deallocate(first_occurrence)\n    \nend program longest_subarray\n", "tests": [{"input": "1\n0\n", "output": "1"}, {"input": "1\n5\n", "output": "0"}, {"input": "3\n0 0 0\n", "output": "3"}, {"input": "4\n2 -2 3 -3\n", "output": "4"}, {"input": "7\n1 2 -2 4 -4 2 -2\n", "output": "6"}, {"input": "7\n1 -1 2 -2 3 -3 4\n", "output": "6"}, {"input": "6\n3 4 -7 5 -6 6\n", "output": "3"}, {"input": "4\n0 1 -1 0\n", "output": "4"}, {"input": "3\n1 2 3\n", "output": "0"}, {"input": "6\n1 2 -3 3 -3 3\n", "output": "5"}], "raw_generation": []}
{"task_id": "Fortran/0004", "language": "Fortran", "difficulty": "hard", "instruction": "Read a line and check balanced brackets for ()[]{} with nesting; print YES/NO.", "prompt": "Read a line and check balanced brackets for ()[]{} with nesting; print YES/NO.", "mode": "io", "canonical_solution": "program balanced_brackets\n    implicit none\n    character(len=10000) :: line\n    character(len=10000) :: stack\n    integer :: i, top, n\n    character :: ch, expected\n    logical :: balanced\n    \n    read(*,'(A)') line\n    n = len_trim(line)\n    \n    top = 0\n    balanced = .true.\n    \n    do i = 1, n\n        ch = line(i:i)\n        \n        if (ch == '(' .or. ch == '[' .or. ch == '{') then\n            top = top + 1\n            stack(top:top) = ch\n        else if (ch == ')' .or. ch == ']' .or. ch == '}') then\n            if (top == 0) then\n                balanced = .false.\n                exit\n            end if\n            \n            if (ch == ')') then\n                expected = '('\n            else if (ch == ']') then\n                expected = '['\n            else if (ch == '}') then\n                expected = '{'\n            end if\n            \n            if (stack(top:top) /= expected) then\n                balanced = .false.\n                exit\n            end if\n            \n            top = top - 1\n        end if\n    end do\n    \n    if (balanced .and. top == 0) then\n        print *, 'YES'\n    else\n        print *, 'NO'\n    end if\n    \nend program balanced_brackets\n", "tests": [{"input": "", "output": "YES"}, {"input": "()", "output": "YES"}, {"input": "([]){}", "output": "YES"}, {"input": "(", "output": "NO"}, {"input": "(]", "output": "NO"}, {"input": "{[()()]}", "output": "YES"}, {"input": "())", "output": "NO"}, {"input": "{[}]", "output": "NO"}, {"input": "hello(world)", "output": "YES"}, {"input": "abc123", "output": "YES"}, {"input": "([)]", "output": "NO"}, {"input": "[([]{})({}[])]", "output": "YES"}, {"input": "][", "output": "NO"}, {"input": "[ { ( ) } ]", "output": "YES"}], "raw_generation": []}
{"task_id": "Fortran/0005", "language": "Fortran", "difficulty": "hard", "instruction": "Read n and n integers; print the length of the longest increasing subsequence (not necessarily contiguous).", "prompt": "Read n and n integers; print the length of the longest increasing subsequence (not necessarily contiguous).", "mode": "io", "canonical_solution": "program longest_increasing_subsequence\n    implicit none\n    integer :: n, i, j, max_len\n    integer, allocatable :: arr(:), dp(:)\n    \n    read(*,*) n\n    allocate(arr(n), dp(n))\n    \n    read(*,*) (arr(i), i=1,n)\n    \n    dp = 1\n    \n    do i = 2, n\n        do j = 1, i-1\n            if (arr(j) < arr(i)) then\n                dp(i) = max(dp(i), dp(j) + 1)\n            end if\n        end do\n    end do\n    \n    max_len = maxval(dp)\n    print *, max_len\n    \n    deallocate(arr, dp)\nend program longest_increasing_subsequence\n", "tests": [{"input": "0", "output": "0"}, {"input": "1\n42", "output": "1"}, {"input": "5\n1 2 3 4 5", "output": "5"}, {"input": "5\n5 4 3 2 1", "output": "1"}, {"input": "8\n2 2 2 2 2 2 2 2", "output": "1"}, {"input": "10\n3 4 1 2 8 5 6 7 2 9", "output": "6"}, {"input": "7\n-1 -2 -3 -4 0 1 2", "output": "4"}, {"input": "9\n1 3 5 4 7 6 8 2 9", "output": "6"}, {"input": "10\n10 9 2 5 3 7 101 18 0 100", "output": "5"}, {"input": "14\n5 1 6 2 7 3 8 4 9 0 10 -1 11 12", "output": "8"}], "raw_generation": []}
{"task_id": "Fortran/0006", "language": "Fortran", "difficulty": "hard", "instruction": "Read a CSV line with quotes and commas; parse fields and print field count. Quotes may contain commas and escaped quotes \"\".", "prompt": "Read a CSV line with quotes and commas; parse fields and print field count. Quotes may contain commas and escaped quotes \"\".", "mode": "io", "canonical_solution": "program parse_csv\n    implicit none\n    character(len=10000) :: line\n    character(len=1000), allocatable :: fields(:)\n    integer :: field_count\n    \n    read(*, '(A)') line\n    call parse_csv_line(trim(line), fields, field_count)\n    print *, field_count\n    \ncontains\n\n    subroutine parse_csv_line(line, fields, field_count)\n        character(len=*), intent(in) :: line\n        character(len=1000), allocatable, intent(out) :: fields(:)\n        integer, intent(out) :: field_count\n        integer :: i, len_line, start_pos\n        character(len=1000) :: current_field\n        logical :: in_quotes\n        character(len=1) :: ch, next_ch\n        integer :: field_pos\n        integer, parameter :: max_fields = 1000\n        character(len=1000) :: temp_fields(max_fields)\n        \n        field_count = 0\n        len_line = len_trim(line)\n        if (len_line == 0) return\n        \n        i = 1\n        in_quotes = .false.\n        current_field = ''\n        field_pos = 0\n        \n        do while (i <= len_line)\n            ch = line(i:i)\n            \n            if (in_quotes) then\n                if (ch == '\"') then\n                    if (i < len_line) then\n                        next_ch = line(i+1:i+1)\n                        if (next_ch == '\"') then\n                            field_pos = field_pos + 1\n                            current_field(field_pos:field_pos) = '\"'\n                            i = i + 2\n                            cycle\n                        else\n                            in_quotes = .false.\n                            i = i + 1\n                            cycle\n                        end if\n                    else\n                        in_quotes = .false.\n                        i = i + 1\n                        cycle\n                    end if\n                else\n                    field_pos = field_pos + 1\n                    current_field(field_pos:field_pos) = ch\n                    i = i + 1\n                end if\n            else\n                if (ch == '\"') then\n                    in_quotes = .true.\n                    i = i + 1\n                else if (ch == ',') then\n                    field_count = field_count + 1\n                    temp_fields(field_count) = current_field(1:field_pos)\n                    current_field = ''\n                    field_pos = 0\n                    i = i + 1\n                else\n                    field_pos = field_pos + 1\n                    current_field(field_pos:field_pos) = ch\n                    i = i + 1\n                end if\n            end if\n        end do\n        \n        field_count = field_count + 1\n        temp_fields(field_count) = current_field(1:field_pos)\n        \n        allocate(fields(field_count))\n        fields(1:field_count) = temp_fields(1:field_count)\n        \n    end subroutine parse_csv_line\n\nend program parse_csv\n", "tests": [{"input": "a,b,c", "output": "3"}, {"input": "\"a,b\",c", "output": "2"}, {"input": "\"He said \"\"Hello\"\"\",world", "output": "2"}, {"input": "a,,c,,", "output": "5"}, {"input": "\"\"", "output": "1"}, {"input": "\"\",\"\",\"\"", "output": "3"}, {"input": "\"\",\",\"", "output": "2"}, {"input": "\",,,\",x", "output": "2"}, {"input": "\"a\"\"b\",c", "output": "2"}, {"input": "a,b,", "output": "3"}, {"input": "\"one\",\"two\",\"th\"\"ree\"", "output": "3"}, {"input": "abc", "output": "1"}, {"input": ",a", "output": "2"}], "raw_generation": []}
{"task_id": "Fortran/0007", "language": "Fortran", "difficulty": "hard", "instruction": "Read a string s and integer k; print the lexicographically smallest substring of length k.", "prompt": "Read a string s and integer k; print the lexicographically smallest substring of length k.", "mode": "io", "canonical_solution": "program smallest_substring\n    implicit none\n    character(len=1000) :: s\n    integer :: k, n, i, min_pos\n    character(len=1000) :: min_substr, current_substr\n    \n    read(*,*) s\n    read(*,*) k\n    \n    n = len_trim(s)\n    \n    min_substr = s(1:k)\n    min_pos = 1\n    \n    do i = 2, n - k + 1\n        current_substr = s(i:i+k-1)\n        if (llt(current_substr, min_substr)) then\n            min_substr = current_substr\n            min_pos = i\n        end if\n    end do\n    \n    print '(a)', trim(min_substr)\n    \nend program smallest_substring\n", "tests": [{"input": "abcde\n2\n", "output": "ab"}, {"input": "zxy\n1\n", "output": "x"}, {"input": "banana\n3\n", "output": "ana"}, {"input": "aaaaa\n2\n", "output": "aa"}, {"input": "cabba\n2\n", "output": "ab"}, {"input": "bcaa\n2\n", "output": "aa"}, {"input": "leetcode\n3\n", "output": "cod"}, {"input": "azaaaz\n3\n", "output": "aaa"}, {"input": "qwerty\n6\n", "output": "qwerty"}], "raw_generation": []}
{"task_id": "Fortran/0008", "language": "Fortran", "difficulty": "hard", "instruction": "Read n and then n intervals [l,r]; merge and output total covered length.", "prompt": "Read n and then n intervals [l,r]; merge and output total covered length.", "mode": "io", "canonical_solution": "program merge_intervals\n    implicit none\n    integer :: n, i, j\n    integer, allocatable :: l(:), r(:)\n    integer, allocatable :: sorted_l(:), sorted_r(:)\n    integer :: current_start, current_end, total_length\n    \n    read*, n\n    allocate(l(n), r(n))\n    allocate(sorted_l(n), sorted_r(n))\n    \n    do i = 1, n\n        read*, l(i), r(i)\n    end do\n    \n    ! Sort intervals by start point (simple bubble sort)\n    sorted_l = l\n    sorted_r = r\n    do i = 1, n-1\n        do j = i+1, n\n            if (sorted_l(j) < sorted_l(i)) then\n                call swap(sorted_l(i), sorted_l(j))\n                call swap(sorted_r(i), sorted_r(j))\n            end if\n        end do\n    end do\n    \n    ! Merge intervals and calculate total length\n    total_length = 0\n    current_start = sorted_l(1)\n    current_end = sorted_r(1)\n    \n    do i = 2, n\n        if (sorted_l(i) <= current_end) then\n            current_end = max(current_end, sorted_r(i))\n        else\n            total_length = total_length + (current_end - current_start)\n            current_start = sorted_l(i)\n            current_end = sorted_r(i)\n        end if\n    end do\n    \n    total_length = total_length + (current_end - current_start)\n    \n    print*, total_length\n    \n    deallocate(l, r, sorted_l, sorted_r)\n    \ncontains\n    subroutine swap(a, b)\n        integer, intent(inout) :: a, b\n        integer :: temp\n        temp = a\n        a = b\n        b = temp\n    end subroutine swap\n    \nend program merge_intervals\n", "tests": [{"input": "3\n1 3\n5 6\n7 10\n", "output": "6\n"}, {"input": "3\n1 5\n2 4\n3 10\n", "output": "9\n"}, {"input": "2\n-3 0\n0 2\n", "output": "5\n"}, {"input": "5\n0 0\n1 2\n2 2\n2 5\n1 5\n", "output": "4\n"}, {"input": "2\n0 1000000000\n-1000000000 0\n", "output": "2000000000\n"}, {"input": "6\n5 7\n1 3\n2 6\n10 12\n12 15\n14 20\n", "output": "16\n"}, {"input": "4\n2 8\n2 8\n2 8\n2 8\n", "output": "6\n"}, {"input": "1\n-5 -2\n", "output": "3\n"}, {"input": "7\n0 2\n4 6\n1 5\n6 9\n9 9\n9 12\n12 12\n", "output": "12\n"}, {"input": "4\n-10 -5\n-3 -1\n0 0\n1 3\n", "output": "9\n"}], "raw_generation": []}
{"task_id": "Fortran/0009", "language": "Fortran", "difficulty": "hard", "instruction": "Read a string; print 1 if it is a valid IPv4 address, else 0.", "prompt": "Read a string; print 1 if it is a valid IPv4 address, else 0.", "mode": "io", "canonical_solution": "program ipv4_validator\n    implicit none\n    character(len=100) :: input_str\n    integer :: result\n    \n    read(*,'(A)') input_str\n    result = validate_ipv4(trim(input_str))\n    print '(I1)', result\n    \ncontains\n    \n    function validate_ipv4(str) result(valid)\n        character(len=*), intent(in) :: str\n        integer :: valid\n        integer :: parts(4)\n        integer :: dot_count, i, j, start_pos, part_idx\n        integer :: num, stat\n        character(len=20) :: part_str\n        logical :: has_digit\n        \n        valid = 0\n        dot_count = 0\n        part_idx = 0\n        start_pos = 1\n        \n        ! Count dots\n        do i = 1, len_trim(str)\n            if (str(i:i) == '.') dot_count = dot_count + 1\n        end do\n        \n        if (dot_count /= 3) return\n        \n        ! Parse parts\n        do i = 1, len_trim(str) + 1\n            if (i > len_trim(str) .or. str(i:i) == '.') then\n                if (i == start_pos) return  ! empty part\n                part_str = str(start_pos:i-1)\n                \n                ! Check for leading zeros\n                if (len_trim(part_str) > 1 .and. part_str(1:1) == '0') return\n                \n                ! Check all characters are digits\n                has_digit = .false.\n                do j = 1, len_trim(part_str)\n                    if (part_str(j:j) < '0' .or. part_str(j:j) > '9') return\n                    has_digit = .true.\n                end do\n                \n                if (.not. has_digit) return\n                \n                ! Convert to integer\n                read(part_str, *, iostat=stat) num\n                if (stat /= 0) return\n                \n                ! Check range\n                if (num < 0 .or. num > 255) return\n                \n                part_idx = part_idx + 1\n                if (part_idx > 4) return\n                parts(part_idx) = num\n                start_pos = i + 1\n            end if\n        end do\n        \n        if (part_idx == 4) valid = 1\n        \n    end function validate_ipv4\n    \nend program ipv4_validator\n", "tests": [{"input": "192.168.0.1", "output": "1"}, {"input": "255.255.255.255", "output": "1"}, {"input": "0.0.0.0", "output": "1"}, {"input": "12.34.56.78", "output": "1"}, {"input": "0.10.0.0", "output": "1"}, {"input": "256.100.100.100", "output": "0"}, {"input": "192.168.001.1", "output": "0"}, {"input": "1.2.3", "output": "0"}, {"input": "1.2.3.4.5", "output": "0"}, {"input": "1..3.4", "output": "0"}, {"input": "1.2.3.-4", "output": "0"}, {"input": "1.2.3.a", "output": "0"}, {"input": "01.2.3.4", "output": "0"}, {"input": "10.0.0.01", "output": "0"}, {"input": ".1.2.3.4", "output": "0"}, {"input": "1.2.3.4.", "output": "0"}, {"input": "0.00.0.0", "output": "0"}, {"input": "123.456.78.90", "output": "0"}, {"input": "1.2.3.256", "output": "0"}, {"input": "1.2.3.4a", "output": "0"}], "raw_generation": []}
{"task_id": "Fortran/0010", "language": "Fortran", "difficulty": "hard", "instruction": "Read a line; print word frequencies sorted by (-count, word).", "prompt": "Read a line; print word frequencies sorted by (-count, word).", "mode": "io", "canonical_solution": "program word_frequency\n    implicit none\n    character(len=10000) :: line\n    character(len=100), allocatable :: words(:), unique_words(:)\n    integer, allocatable :: counts(:)\n    integer :: i, j, n_words, n_unique, ios\n    character(len=100) :: temp_word\n    integer :: temp_count\n    logical :: found\n    \n    ! Read the line\n    read(*, '(A)', iostat=ios) line\n    if (ios /= 0) stop\n    \n    ! Count words by splitting on spaces\n    n_words = 0\n    allocate(words(10000))\n    \n    call split_line(line, words, n_words)\n    \n    ! Count unique words\n    allocate(unique_words(n_words))\n    allocate(counts(n_words))\n    n_unique = 0\n    \n    do i = 1, n_words\n        found = .false.\n        do j = 1, n_unique\n            if (trim(words(i)) == trim(unique_words(j))) then\n                counts(j) = counts(j) + 1\n                found = .true.\n                exit\n            end if\n        end do\n        if (.not. found) then\n            n_unique = n_unique + 1\n            unique_words(n_unique) = words(i)\n            counts(n_unique) = 1\n        end if\n    end do\n    \n    ! Sort by count (descending), then by word (ascending)\n    do i = 1, n_unique - 1\n        do j = i + 1, n_unique\n            if (counts(j) > counts(i) .or. &\n                (counts(j) == counts(i) .and. trim(unique_words(j)) < trim(unique_words(i)))) then\n                temp_count = counts(i)\n                counts(i) = counts(j)\n                counts(j) = temp_count\n                temp_word = unique_words(i)\n                unique_words(i) = unique_words(j)\n                unique_words(j) = temp_word\n            end if\n        end do\n    end do\n    \n    ! Print results\n    do i = 1, n_unique\n        write(*, '(A,1X,I0)') trim(unique_words(i)), counts(i)\n    end do\n    \ncontains\n    \n    subroutine split_line(str, words_out, n)\n        character(len=*), intent(in) :: str\n        character(len=100), intent(out) :: words_out(:)\n        integer, intent(out) :: n\n        integer :: i, start, str_len\n        logical :: in_word\n        \n        n = 0\n        in_word = .false.\n        start = 1\n        str_len = len_trim(str)\n        \n        do i = 1, str_len\n            if (str(i:i) /= ' ' .and. .not. in_word) then\n                in_word = .true.\n                start = i\n            else if ((str(i:i) == ' ' .or. i == str_len) .and. in_word) then\n                n = n + 1\n                if (str(i:i) == ' ') then\n                    words_out(n) = str(start:i-1)\n                else\n                    words_out(n) = str(start:i)\n                end if\n                in_word = .false.\n            end if\n        end do\n        \n    end subroutine split_line\n    \nend program word_frequency\n", "tests": [{"input": "apple apple banana apple banana", "output": "apple 3\nbanana 2"}, {"input": "b a c b a", "output": "a 2\nb 2\nc 1"}, {"input": "Dog dog DOG", "output": "DOG 1\nDog 1\ndog 1"}, {"input": "hello, hello world! world!", "output": "world! 2\nhello 1\nhello, 1"}, {"input": "  one   two   two\ttwo  ", "output": "two 3\none 1"}, {"input": "3 2 1 2 3 3 + + -", "output": "3 3\n+ 2\n2 2\n- 1\n1 1"}, {"input": "", "output": ""}, {"input": "abc abc ABC abc123 ABC abc123", "output": "ABC 2\nabc 2\nabc123 2"}], "raw_generation": []}
{"task_id": "Fortran/0011", "language": "Fortran", "difficulty": "hard", "instruction": "Given n,m and a grid of '.' and '#', count connected components (4-direction).", "prompt": "Given n,m and a grid of '.' and '#', count connected components (4-direction).", "mode": "io", "canonical_solution": "program connected_components\n    implicit none\n    integer :: n, m, i, j, count\n    character(len=1), allocatable :: grid(:,:)\n    logical, allocatable :: visited(:,:)\n    \n    read*, n, m\n    allocate(grid(n,m))\n    allocate(visited(n,m))\n    \n    do i = 1, n\n        read*, (grid(i,j), j=1,m)\n    end do\n    \n    visited = .false.\n    count = 0\n    \n    do i = 1, n\n        do j = 1, m\n            if (grid(i,j) == '.' .and. .not. visited(i,j)) then\n                count = count + 1\n                call dfs(i, j, n, m, grid, visited)\n            end if\n        end do\n    end do\n    \n    print*, count\n    \n    deallocate(grid)\n    deallocate(visited)\n    \ncontains\n    \n    recursive subroutine dfs(row, col, n, m, grid, visited)\n        integer, intent(in) :: row, col, n, m\n        character(len=1), intent(in) :: grid(n,m)\n        logical, intent(inout) :: visited(n,m)\n        integer :: dr(4), dc(4), i, nr, nc\n        \n        dr = [0, 0, 1, -1]\n        dc = [1, -1, 0, 0]\n        \n        visited(row, col) = .true.\n        \n        do i = 1, 4\n            nr = row + dr(i)\n            nc = col + dc(i)\n            \n            if (nr >= 1 .and. nr <= n .and. nc >= 1 .and. nc <= m) then\n                if (grid(nr,nc) == '.' .and. .not. visited(nr,nc)) then\n                    call dfs(nr, nc, n, m, grid, visited)\n                end if\n            end if\n        end do\n    end subroutine dfs\n    \nend program connected_components\n", "tests": [{"input": "1 1\n.\n", "output": "0\n"}, {"input": "1 1\n#\n", "output": "1\n"}, {"input": "2 3\n.#.\n#.#\n", "output": "3\n"}, {"input": "3 3\n.#.\n###\n.#.\n", "output": "1\n"}, {"input": "3 3\n#..\n.#.\n..#\n", "output": "3\n"}, {"input": "2 4\n####\n####\n", "output": "1\n"}, {"input": "1 5\n#.#.#\n", "output": "3\n"}, {"input": "5 1\n#\n.\n#\n.\n#\n", "output": "3\n"}, {"input": "4 5\n##..#\n#..##\n..##.\n#....\n", "output": "3\n"}], "raw_generation": []}
{"task_id": "Fortran/0012", "language": "Fortran", "difficulty": "hard", "instruction": "Read a line; run-length encode (RLE) it as <char><count> without separators.", "prompt": "Read a line; run-length encode (RLE) it as <char><count> without separators.", "mode": "io", "canonical_solution": "program rle\n    implicit none\n    character(len=1000) :: line\n    integer :: i, count, len_line\n    character(len=1) :: current_char\n    \n    read(*,'(A)') line\n    len_line = len_trim(line)\n    \n    if (len_line == 0) then\n        stop\n    end if\n    \n    current_char = line(1:1)\n    count = 1\n    \n    do i = 2, len_line\n        if (line(i:i) == current_char) then\n            count = count + 1\n        else\n            write(*,'(A,I0)',advance='no') current_char, count\n            current_char = line(i:i)\n            count = 1\n        end if\n    end do\n    \n    write(*,'(A,I0)') current_char, count\n    \nend program rle\n", "tests": [{"input": "AAAA", "output": "A4"}, {"input": "ABC", "output": "A1B1C1"}, {"input": "", "output": ""}, {"input": "111223330", "output": "13223301"}, {"input": "a  b", "output": "a1 2b1"}, {"input": "!!!??", "output": "!3?2"}, {"input": "AaAa", "output": "A1a1A1a1"}, {"input": "BBBBBBBBBBBB", "output": "B12"}, {"input": "  a", "output": " 2a1"}, {"input": "0000000000", "output": "010"}, {"input": "A12A", "output": "A11121A1"}, {"input": "    ", "output": " 4"}, {"input": "aaabbbcccaaa", "output": "a3b3c3a3"}, {"input": "Z", "output": "Z1"}], "raw_generation": []}
{"task_id": "Fortran/0013", "language": "Fortran", "difficulty": "hard", "instruction": "Read two big integers (up to 10^500) as strings; print their sum.", "prompt": "Read two big integers (up to 10^500) as strings; print their sum.", "mode": "io", "canonical_solution": "program big_integer_sum\n    implicit none\n    character(len=1000) :: a, b, result\n    integer :: len_a, len_b, len_max, i, carry, digit_a, digit_b, sum_digit\n    integer, allocatable :: num_a(:), num_b(:), num_result(:)\n    \n    read(*,*) a\n    read(*,*) b\n    \n    a = adjustl(a)\n    b = adjustl(b)\n    len_a = len_trim(a)\n    len_b = len_trim(b)\n    len_max = max(len_a, len_b) + 1\n    \n    allocate(num_a(len_max))\n    allocate(num_b(len_max))\n    allocate(num_result(len_max))\n    \n    num_a = 0\n    num_b = 0\n    num_result = 0\n    \n    do i = 1, len_a\n        num_a(len_max - len_a + i) = ichar(a(i:i)) - ichar('0')\n    end do\n    \n    do i = 1, len_b\n        num_b(len_max - len_b + i) = ichar(b(i:i)) - ichar('0')\n    end do\n    \n    carry = 0\n    do i = len_max, 1, -1\n        sum_digit = num_a(i) + num_b(i) + carry\n        num_result(i) = mod(sum_digit, 10)\n        carry = sum_digit / 10\n    end do\n    \n    result = ''\n    i = 1\n    do while (i <= len_max .and. num_result(i) == 0)\n        i = i + 1\n    end do\n    \n    if (i > len_max) then\n        print *, '0'\n    else\n        do while (i <= len_max)\n            result = trim(result) // char(num_result(i) + ichar('0'))\n            i = i + 1\n        end do\n        print *, trim(result)\n    end if\n    \n    deallocate(num_a)\n    deallocate(num_b)\n    deallocate(num_result)\n    \nend program big_integer_sum\n", "tests": [{"input": "123 456", "output": "579"}, {"input": "999999999999999999999\n1", "output": "1000000000000000000000"}, {"input": "0000123\n0000777", "output": "900"}, {"input": "   0\n0   ", "output": "0"}, {"input": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "output": "2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222"}, {"input": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n1", "output": "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"input": "-12345\n6789", "output": "-5556"}, {"input": "-123\n123", "output": "0"}, {"input": "-999\n-1", "output": "-1000"}, {"input": "\t+42\n58", "output": "100"}], "raw_generation": []}
{"task_id": "Fortran/0014", "language": "Fortran", "difficulty": "hard", "instruction": "Given n,m and edges (1-indexed), output a topological ordering or print -1 if cycle.", "prompt": "Given n,m and edges (1-indexed), output a topological ordering or print -1 if cycle.", "mode": "io", "canonical_solution": "program topological_sort\n    implicit none\n    integer :: n, m, i, j, u, v\n    integer, allocatable :: adj(:,:), indegree(:), result(:)\n    integer :: queue(100000), front, rear, count, node\n    logical :: has_cycle\n    \n    read(*,*) n, m\n    \n    allocate(adj(n, n))\n    allocate(indegree(n))\n    allocate(result(n))\n    \n    adj = 0\n    indegree = 0\n    \n    do i = 1, m\n        read(*,*) u, v\n        if (adj(u, v) == 0) then\n            adj(u, v) = 1\n            indegree(v) = indegree(v) + 1\n        end if\n    end do\n    \n    front = 1\n    rear = 0\n    \n    do i = 1, n\n        if (indegree(i) == 0) then\n            rear = rear + 1\n            queue(rear) = i\n        end if\n    end do\n    \n    count = 0\n    \n    do while (front <= rear)\n        node = queue(front)\n        front = front + 1\n        count = count + 1\n        result(count) = node\n        \n        do i = 1, n\n            if (adj(node, i) == 1) then\n                indegree(i) = indegree(i) - 1\n                if (indegree(i) == 0) then\n                    rear = rear + 1\n                    queue(rear) = i\n                end if\n            end if\n        end do\n    end do\n    \n    if (count /= n) then\n        print *, -1\n    else\n        do i = 1, n\n            if (i == n) then\n                print *, result(i)\n            else\n                write(*, '(I0, A)', advance='no') result(i), ' '\n            end if\n        end do\n    end if\n    \n    deallocate(adj)\n    deallocate(indegree)\n    deallocate(result)\n    \nend program topological_sort\n", "tests": [{"input": "1 0\n", "output": "1\n"}, {"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": "1 2 3 4 5\n"}, {"input": "3 3\n1 2\n2 3\n3 1\n", "output": "-1\n"}, {"input": "3 1\n2 2\n", "output": "-1\n"}, {"input": "6 8\n1 2\n1 3\n2 4\n3 4\n2 5\n4 5\n5 6\n2 3\n", "output": "1 2 3 4 5 6\n"}, {"input": "4 5\n1 2\n1 2\n2 3\n2 3\n3 4\n", "output": "1 2 3 4\n"}, {"input": "5 5\n1 2\n2 3\n3 2\n3 4\n4 5\n", "output": "-1\n"}, {"input": "5 4\n3 1\n1 4\n4 2\n2 5\n", "output": "3 1 4 2 5\n"}], "raw_generation": []}
{"task_id": "Fortran/0015", "language": "Fortran", "difficulty": "hard", "instruction": "Read multiple lines until EOF; output the line with the maximum number of distinct characters (break ties by earliest).", "prompt": "Read multiple lines until EOF; output the line with the maximum number of distinct characters (break ties by earliest).", "mode": "io", "canonical_solution": "program max_distinct_chars\n    implicit none\n    character(len=1000) :: line, max_line\n    integer :: ios, max_count, count\n    logical :: first_line\n    \n    first_line = .true.\n    max_count = -1\n    max_line = ''\n    \n    do\n        read(*, '(A)', iostat=ios) line\n        if (ios /= 0) exit\n        \n        count = count_distinct(trim(line))\n        \n        if (first_line .or. count > max_count) then\n            max_count = count\n            max_line = line\n            first_line = .false.\n        end if\n    end do\n    \n    print '(A)', trim(max_line)\n    \ncontains\n    \n    integer function count_distinct(str)\n        character(len=*), intent(in) :: str\n        logical :: seen(0:255)\n        integer :: i, char_code\n        \n        seen = .false.\n        count_distinct = 0\n        \n        do i = 1, len(str)\n            char_code = ichar(str(i:i))\n            if (.not. seen(char_code)) then\n                seen(char_code) = .true.\n                count_distinct = count_distinct + 1\n            end if\n        end do\n    end function count_distinct\n    \nend program max_distinct_chars\n", "tests": [{"input": "hello\nworld\n", "output": "world"}, {"input": "abcd\nbcda\nabcc\n", "output": "abcd"}, {"input": "aaa\na a a\na A\n", "output": "a A"}, {"input": "\na\n\n", "output": "a"}, {"input": "112233\nabc!?\nab!c?\n", "output": "abc!?"}, {"input": "the quick brown fox\npack my box with five dozen liquor jugs\n", "output": "pack my box with five dozen liquor jugs"}, {"input": "a b\na\tb\na\t b\n", "output": "a\t b"}, {"input": "abc\nABC\nAbC\n", "output": "abc"}, {"input": "foo\nfoo \nfoo  \n", "output": "foo "}, {"input": "aaaaaaaaaa\nabcde\nabcdE\n", "output": "abcde"}], "raw_generation": []}
{"task_id": "Fortran/0016", "language": "Fortran", "difficulty": "hard", "instruction": "Read a line; evaluate a simple expression with + - * / and parentheses (integers, no unary minus), print result.", "prompt": "Read a line; evaluate a simple expression with + - * / and parentheses (integers, no unary minus), print result.", "mode": "io", "canonical_solution": "program calculator\n    implicit none\n    character(len=1000) :: line\n    integer :: pos\n    real :: result\n    \n    read(*,'(A)') line\n    pos = 1\n    result = parse_expr(line, pos)\n    print *, int(result)\n    \ncontains\n\n    recursive function parse_expr(s, p) result(val)\n        character(len=*), intent(in) :: s\n        integer, intent(inout) :: p\n        real :: val, right\n        character(len=1) :: op\n        \n        val = parse_term(s, p)\n        do while (p <= len_trim(s))\n            call skip_spaces(s, p)\n            if (p > len_trim(s)) exit\n            if (s(p:p) /= '+' .and. s(p:p) /= '-') exit\n            op = s(p:p)\n            p = p + 1\n            right = parse_term(s, p)\n            if (op == '+') then\n                val = val + right\n            else\n                val = val - right\n            end if\n        end do\n    end function parse_expr\n    \n    recursive function parse_term(s, p) result(val)\n        character(len=*), intent(in) :: s\n        integer, intent(inout) :: p\n        real :: val, right\n        character(len=1) :: op\n        \n        val = parse_factor(s, p)\n        do while (p <= len_trim(s))\n            call skip_spaces(s, p)\n            if (p > len_trim(s)) exit\n            if (s(p:p) /= '*' .and. s(p:p) /= '/') exit\n            op = s(p:p)\n            p = p + 1\n            right = parse_factor(s, p)\n            if (op == '*') then\n                val = val * right\n            else\n                val = val / right\n            end if\n        end do\n    end function parse_term\n    \n    recursive function parse_factor(s, p) result(val)\n        character(len=*), intent(in) :: s\n        integer, intent(inout) :: p\n        real :: val\n        \n        call skip_spaces(s, p)\n        if (s(p:p) == '(') then\n            p = p + 1\n            val = parse_expr(s, p)\n            call skip_spaces(s, p)\n            p = p + 1  ! skip ')'\n        else\n            val = parse_number(s, p)\n        end if\n    end function parse_factor\n    \n    function parse_number(s, p) result(val)\n        character(len=*), intent(in) :: s\n        integer, intent(inout) :: p\n        real :: val\n        integer :: start\n        \n        call skip_spaces(s, p)\n        start = p\n        do while (p <= len_trim(s) .and. (s(p:p) >= '0' .and. s(p:p) <= '9'))\n            p = p + 1\n        end do\n        read(s(start:p-1), *) val\n    end function parse_number\n    \n    subroutine skip_spaces(s, p)\n        character(len=*), intent(in) :: s\n        integer, intent(inout) :: p\n        \n        do while (p <= len_trim(s) .and. s(p:p) == ' ')\n            p = p + 1\n        end do\n    end subroutine skip_spaces\n\nend program calculator\n", "tests": [{"input": "2+3*4", "output": "14"}, {"input": "(2+3)*4", "output": "20"}, {"input": "18/3/2", "output": "3"}, {"input": "7-4-1", "output": "2"}, {"input": "8/3", "output": "2"}, {"input": "  12 + 34  * (  5 - 2 ) ", "output": "114"}, {"input": "((1+2)*(3+4)-5)/2", "output": "8"}, {"input": "((2+3)*(4+(5*6)))", "output": "170"}, {"input": "0*1000+5", "output": "5"}, {"input": "1+8/4+3", "output": "6"}, {"input": "42", "output": "42"}, {"input": "123456*7+89", "output": "864281"}, {"input": "(123456*7+89)/10", "output": "86428"}, {"input": "3-10/2*3", "output": "-12"}, {"input": "100/(2+3*4)", "output": "7"}], "raw_generation": []}
{"task_id": "Fortran/0017", "language": "Fortran", "difficulty": "hard", "instruction": "Read string s; print length of the longest substring without repeating characters.", "prompt": "Read string s; print length of the longest substring without repeating characters.", "mode": "io", "canonical_solution": "program longest_substring\n    implicit none\n    character(len=100000) :: s\n    integer :: n, i, j, maxlen, start\n    logical :: found\n    character(len=1), allocatable :: current(:)\n    \n    read(*,'(A)') s\n    n = len_trim(s)\n    \n    maxlen = 0\n    \n    do i = 1, n\n        allocate(current(0))\n        do j = i, n\n            found = .false.\n            do start = 1, size(current)\n                if (current(start) == s(j:j)) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            \n            if (found) then\n                exit\n            else\n                current = [current, s(j:j)]\n                if (size(current) > maxlen) then\n                    maxlen = size(current)\n                end if\n            end if\n        end do\n        deallocate(current)\n    end do\n    \n    print *, maxlen\nend program longest_substring\n", "tests": [{"input": "", "output": "0"}, {"input": "a", "output": "1"}, {"input": "aaaaa", "output": "1"}, {"input": "abcabcbb", "output": "3"}, {"input": "bbbbb", "output": "1"}, {"input": "pwwkew", "output": "3"}, {"input": "abcdef", "output": "6"}, {"input": "AaBbCc", "output": "6"}, {"input": "abc def", "output": "7"}, {"input": "abba", "output": "2"}, {"input": "dvdf", "output": "3"}, {"input": "tmmzuxt", "output": "5"}, {"input": "abc!@#abc", "output": "6"}, {"input": "anviaj", "output": "5"}, {"input": "123451234", "output": "5"}], "raw_generation": []}
{"task_id": "Fortran/0018", "language": "Fortran", "difficulty": "easy", "instruction": "Read a line containing integers separated by commas and/or spaces; print their sum.", "prompt": "Read a line containing integers separated by commas and/or spaces; print their sum.", "mode": "io", "canonical_solution": "```fortran\nprogram sum_integers\n    implicit none\n    character(len=1000) :: line\n    integer :: i, j, n, total, num, ios\n    character(len=20) :: temp\n    logical :: in_number\n    \n    read(*,'(A)') line\n    \n    total = 0\n    temp = ''\n    in_number = .false.\n    n = len_trim(line)\n    \n    do i = 1, n\n        if (line(i:i) >= '0' .and. line(i:i) <= '9' .or. &\n            line(i:i) == '-' .or. line(i:i) == '+') then\n            temp = trim(temp) // line(i:i)\n            in_number = .true.\n        else if (line(i:i) == ',' .or. line(i:i) == ' ') then\n            if (in_number .and. len_trim(temp) > 0) then\n                read(temp, *, iostat=ios) num\n                if (ios == 0) total = total + num\n                temp = ''\n                in_number = .false.\n            end if\n        end if\n    end do\n    \n    if (in_number .and. len_trim(temp) > 0) then\n        read(temp, *, iostat=ios) num\n        if (ios == 0) total = total + num\n    end if\n    \n    print *, total\nend program sum_integers\n```", "tests": [{"input": "1 2 3", "output": "6"}, {"input": "1,2,3", "output": "6"}, {"input": "1, 2  ,3  4", "output": "10"}, {"input": "-1, -2 3", "output": "0"}, {"input": "  7 , 8,9   ", "output": "24"}, {"input": "10", "output": "10"}, {"input": "+5, -3, +2, -4, 0", "output": "0"}, {"input": "12,34 56,78 90", "output": "270"}, {"input": "1,2,3,4,5,6,7,8,9,10", "output": "55"}, {"input": "999999999, 1000000000", "output": "1999999999"}], "raw_generation": []}
{"task_id": "Fortran/0019", "language": "Fortran", "difficulty": "easy", "instruction": "Read n,m then m edges (1-indexed). Print the degree of each node on one line separated by spaces.", "prompt": "Read n,m then m edges (1-indexed). Print the degree of each node on one line separated by spaces.", "mode": "io", "canonical_solution": "```fortran\nprogram node_degrees\n    implicit none\n    integer :: n, m, i, u, v\n    integer, allocatable :: degree(:)\n    \n    read*, n, m\n    allocate(degree(n))\n    degree = 0\n    \n    do i = 1, m\n        read*, u, v\n        degree(u) = degree(u) + 1\n        degree(v) = degree(v) + 1\n    end do\n    \n    do i = 1, n\n        if (i == n) then\n            write(*, '(I0)') degree(i)\n        else\n            write(*, '(I0, A)', advance='no') degree(i), ' '\n        end if\n    end do\n    \n    deallocate(degree)\nend program node_degrees\n```", "tests": [{"input": "3 2\n1 2\n2 3\n", "output": "1 2 1\n"}, {"input": "5 0\n", "output": "0 0 0 0 0\n"}, {"input": "4 5\n1 2\n2 3\n1 2\n2 4\n4 1\n", "output": "3 4 1 2\n"}, {"input": "6 3\n2 3\n2 5\n4 6\n", "output": "0 2 1 1 1 1\n"}, {"input": "7 6\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n", "output": "6 1 1 1 1 1 1\n"}, {"input": "5 6\n1 2\n2 3\n3 4\n4 5\n3 2\n5 1\n", "output": "2 3 3 2 2\n"}, {"input": "3 3\n1 2\n2 1\n2 1\n", "output": "3 3 0\n"}, {"input": "8 4\n1 8\n2 7\n3 6\n3 6\n", "output": "1 1 2 0 0 2 1 1\n"}], "raw_generation": []}
{"task_id": "Fortran/0020", "language": "Fortran", "difficulty": "easy", "instruction": "Given n, print the sum of the digits of n.", "prompt": "Given n, print the sum of the digits of n.", "mode": "io", "canonical_solution": "```fortran\nprogram sum_of_digits\n    implicit none\n    integer :: n, digit_sum, digit\n    \n    read*, n\n    \n    n = abs(n)\n    digit_sum = 0\n    \n    do while (n > 0)\n        digit = mod(n, 10)\n        digit_sum = digit_sum + digit\n        n = n / 10\n    end do\n    \n    print*, digit_sum\n    \nend program sum_of_digits\n```", "tests": [{"input": "0", "output": "0"}, {"input": "7", "output": "7"}, {"input": "10", "output": "1"}, {"input": "12345", "output": "15"}, {"input": "1002003", "output": "6"}, {"input": "999999999", "output": "81"}, {"input": "-56009", "output": "20"}, {"input": "9223372036854775807", "output": "88"}, {"input": "0000123", "output": "6"}, {"input": "12345678901234567890123456789012345678901234567890", "output": "225"}], "raw_generation": []}
{"task_id": "Fortran/0021", "language": "Fortran", "difficulty": "easy", "instruction": "Read all input and print the number of lines, words, and bytes (like wc).", "prompt": "Read all input and print the number of lines, words, and bytes (like wc).", "mode": "io", "canonical_solution": "```fortran\nprogram wc\n    implicit none\n    integer :: ios, lines, words, bytes, i, len_trim\n    character(len=10000) :: line\n    character :: c, prev_c\n    logical :: in_word\n    \n    lines = 0\n    words = 0\n    bytes = 0\n    \n    do\n        read(*, '(A)', iostat=ios, advance='no', size=i) line\n        \n        if (ios > 0) then\n            exit\n        else if (ios < 0) then\n            if (i > 0) then\n                lines = lines + 1\n                bytes = bytes + i\n                \n                in_word = .false.\n                do i = 1, len_trim(line)\n                    c = line(i:i)\n                    if (c /= ' ' .and. c /= char(9) .and. c /= char(10) .and. c /= char(13)) then\n                        if (.not. in_word) then\n                            words = words + 1\n                            in_word = .true.\n                        end if\n                    else\n                        in_word = .false.\n                    end if\n                end do\n            end if\n            exit\n        else\n            lines = lines + 1\n            bytes = bytes + i + 1\n            \n            in_word = .false.\n            do i = 1, len_trim(line)\n                c = line(i:i)\n                if (c /= ' ' .and. c /= char(9) .and. c /= char(10) .and. c /= char(13)) then\n                    if (.not. in_word) then\n                        words = words + 1\n                        in_word = .true.\n                    end if\n                else\n                    in_word = .false.\n                end if\n            end do\n        end if\n    end do\n    \n    print '(I0, 1X, I0, 1X, I0)', lines, words, bytes\nend program wc\n```", "tests": [{"input": "", "output": "0 0 0\n"}, {"input": "Hello world\n", "output": "1 2 12\n"}, {"input": "Hello    world\tthis  is\n a\ttest", "output": "1 6 31\n"}, {"input": "a\n\n\nb\n", "output": "4 2 6\n"}, {"input": "   ", "output": "0 0 3\n"}, {"input": "one,two;three\nfour", "output": "1 2 18\n"}, {"input": "a\tb\tc\n\n", "output": "2 3 7\n"}, {"input": "  leading and trailing  \n", "output": "1 3 25\n"}], "raw_generation": []}
{"task_id": "Fortran/0022", "language": "Fortran", "difficulty": "easy", "instruction": "Read a line and print 'YES' if it is a palindrome ignoring non-alphanumerics and case, else 'NO'.", "prompt": "Read a line and print 'YES' if it is a palindrome ignoring non-alphanumerics and case, else 'NO'.", "mode": "io", "canonical_solution": "```fortran\nprogram palindrome_check\n    implicit none\n    character(len=1000) :: line\n    character(len=1000) :: cleaned\n    integer :: i, j, len_cleaned\n    logical :: is_palindrome\n    character(len=1) :: c\n    \n    read(*,'(A)') line\n    \n    ! Clean the string - keep only alphanumerics and convert to lowercase\n    cleaned = ''\n    j = 0\n    do i = 1, len_trim(line)\n        c = line(i:i)\n        if ((c >= 'A' .and. c <= 'Z')) then\n            j = j + 1\n            cleaned(j:j) = char(ichar(c) + 32)\n        else if ((c >= 'a' .and. c <= 'z') .or. (c >= '0' .and. c <= '9')) then\n            j = j + 1\n            cleaned(j:j) = c\n        end if\n    end do\n    len_cleaned = j\n    \n    ! Check if palindrome\n    is_palindrome = .true.\n    do i = 1, len_cleaned / 2\n        if (cleaned(i:i) /= cleaned(len_cleaned - i + 1:len_cleaned - i + 1)) then\n            is_palindrome = .false.\n            exit\n        end if\n    end do\n    \n    if (is_palindrome) then\n        print '(A)', 'YES'\n    else\n        print '(A)', 'NO'\n    end if\n    \nend program palindrome_check\n```", "tests": [{"input": "A man, a plan, a canal: Panama!", "output": "YES"}, {"input": "OpenAI", "output": "NO"}, {"input": "", "output": "YES"}, {"input": "!!!", "output": "YES"}, {"input": "12321", "output": "YES"}, {"input": "1231", "output": "NO"}, {"input": "No 'x' in Nixon", "output": "YES"}, {"input": "This is not a palindrome!", "output": "NO"}, {"input": "  RaceCar  ", "output": "YES"}, {"input": "Madam, I'm Adam.", "output": "YES"}], "raw_generation": []}
{"task_id": "Fortran/0023", "language": "Fortran", "difficulty": "easy", "instruction": "Read n,m then m edges (1-indexed). Print the degree of each node on one line separated by spaces.", "prompt": "Read n,m then m edges (1-indexed). Print the degree of each node on one line separated by spaces.", "mode": "io", "canonical_solution": "```fortran\nprogram node_degrees\n    implicit none\n    integer :: n, m, i, u, v\n    integer, allocatable :: degree(:)\n    \n    read*, n, m\n    allocate(degree(n))\n    degree = 0\n    \n    do i = 1, m\n        read*, u, v\n        degree(u) = degree(u) + 1\n        degree(v) = degree(v) + 1\n    end do\n    \n    do i = 1, n\n        if (i == n) then\n            write(*, '(I0)') degree(i)\n        else\n            write(*, '(I0, A)', advance='no') degree(i), ' '\n        end if\n    end do\n    \n    deallocate(degree)\nend program node_degrees\n```", "tests": [{"input": "5 0\n", "output": "0 0 0 0 0\n"}, {"input": "4 3\n1 2\n2 3\n4 2\n", "output": "1 3 1 1\n"}, {"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": "1 2 2 2 1\n"}, {"input": "6 5\n1 2\n1 3\n1 4\n1 5\n1 6\n", "output": "5 1 1 1 1 1\n"}, {"input": "5 10\n1 2\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n3 5\n4 5\n", "output": "4 4 4 4 4\n"}, {"input": "3 4\n1 2\n1 2\n2 3\n2 3\n", "output": "2 4 2\n"}, {"input": "7 3\n7 1\n7 2\n5 6\n", "output": "1 1 0 0 1 1 2\n"}, {"input": "10 7\n2 5\n3 5\n5 9\n1 10\n4 6\n7 8\n8 10\n", "output": "1 1 1 1 3 1 1 2 1 2\n"}], "raw_generation": []}
{"task_id": "Fortran/0024", "language": "Fortran", "difficulty": "easy", "instruction": "Read all input and print the number of lines, words, and bytes (like wc).", "prompt": "Read all input and print the number of lines, words, and bytes (like wc).", "mode": "io", "canonical_solution": "```fortran\nprogram wc\n    implicit none\n    integer :: lines, words, bytes\n    integer :: iostat, i\n    character(len=10000) :: line\n    character :: ch\n    logical :: in_word\n    \n    lines = 0\n    words = 0\n    bytes = 0\n    \n    do\n        read(*, '(A)', iostat=iostat) line\n        if (iostat /= 0) exit\n        \n        lines = lines + 1\n        bytes = bytes + len_trim(line) + 1\n        \n        in_word = .false.\n        do i = 1, len_trim(line)\n            ch = line(i:i)\n            if (ch == ' ' .or. ch == char(9) .or. ch == char(10) .or. ch == char(13)) then\n                in_word = .false.\n            else\n                if (.not. in_word) then\n                    words = words + 1\n                    in_word = .true.\n                end if\n            end if\n        end do\n    end do\n    \n    print '(I0, 1X, I0, 1X, I0)', lines, words, bytes\nend program wc\n```", "tests": [{"input": "", "output": "0 0 0"}, {"input": "\n", "output": "1 0 1"}, {"input": "Hello world\n", "output": "1 2 12"}, {"input": "a\tb c\n\nd\n", "output": "3 4 9"}, {"input": "  leading and  trailing  ", "output": "0 3 25"}, {"input": "foo\nbar", "output": "1 2 7"}, {"input": "\t \t\n\n", "output": "2 0 5"}, {"input": "one  two   three\n", "output": "1 3 17"}], "raw_generation": []}
{"task_id": "Fortran/0025", "language": "Fortran", "difficulty": "easy", "instruction": "Given n, print the smallest k such that k! is divisible by n, or -1 if none within 1..12.", "prompt": "Given n, print the smallest k such that k! is divisible by n, or -1 if none within 1..12.", "mode": "io", "canonical_solution": "```fortran\nprogram factorial_divisibility\n    implicit none\n    integer :: n, k, fact, i\n    logical :: found\n    \n    read*, n\n    \n    found = .false.\n    do k = 1, 12\n        fact = 1\n        do i = 1, k\n            fact = fact * i\n        end do\n        \n        if (mod(fact, n) == 0) then\n            print*, k\n            found = .true.\n            exit\n        end if\n    end do\n    \n    if (.not. found) then\n        print*, -1\n    end if\n    \nend program factorial_divisibility\n```", "tests": [{"input": "1\n", "output": "1\n"}, {"input": "2\n", "output": "2\n"}, {"input": "12\n", "output": "4\n"}, {"input": "27\n", "output": "9\n"}, {"input": "49\n", "output": "-1\n"}, {"input": "1024\n", "output": "12\n"}, {"input": "10\n", "output": "5\n"}, {"input": "36\n", "output": "6\n"}, {"input": "2520\n", "output": "7\n"}, {"input": "40320\n", "output": "8\n"}, {"input": "3628800\n", "output": "10\n"}, {"input": "479001600\n", "output": "12\n"}, {"input": "13\n", "output": "-1\n"}, {"input": "999999999\n", "output": "-1\n"}], "raw_generation": []}
{"task_id": "Fortran/0026", "language": "Fortran", "difficulty": "easy", "instruction": "Read n then n integers. Print the length of the longest strictly increasing contiguous subarray.", "prompt": "Read n then n integers. Print the length of the longest strictly increasing contiguous subarray.", "mode": "io", "canonical_solution": "```fortran\nprogram longest_increasing\n    implicit none\n    integer :: n, i, current_length, max_length\n    integer, allocatable :: arr(:)\n    \n    read*, n\n    allocate(arr(n))\n    \n    do i = 1, n\n        read*, arr(i)\n    end do\n    \n    max_length = 1\n    current_length = 1\n    \n    do i = 2, n\n        if (arr(i) > arr(i-1)) then\n            current_length = current_length + 1\n            if (current_length > max_length) then\n                max_length = current_length\n            end if\n        else\n            current_length = 1\n        end if\n    end do\n    \n    print*, max_length\n    \n    deallocate(arr)\nend program longest_increasing\n```", "tests": [{"input": "1\n42\n", "output": "1"}, {"input": "5\n1 2 3 4 5\n", "output": "5"}, {"input": "5\n5 4 3 2 1\n", "output": "1"}, {"input": "6\n2 2 2 2 2 2\n", "output": "1"}, {"input": "7\n-3 -2 -2 -1 0 0 1\n", "output": "3"}, {"input": "8\n1 3 5 4\n6 8 10 9\n", "output": "4"}, {"input": "9\n1 1 2 3 2\n2 3 4 5\n", "output": "4"}, {"input": "10\n1 2 1 2 1 2 1 2 1 2\n", "output": "2"}, {"input": "4\n2147483646 2147483647 -2147483648 -2147483647\n", "output": "2"}, {"input": "11\n1 2 3 4 5 6 7 8 7 8 9\n", "output": "8"}], "raw_generation": []}
{"task_id": "Fortran/0027", "language": "Fortran", "difficulty": "easy", "instruction": "Read n, print the number of set bits in binary representation of n.", "prompt": "Read n, print the number of set bits in binary representation of n.", "mode": "io", "canonical_solution": "```fortran\nprogram count_set_bits\n    implicit none\n    integer :: n, count, temp\n    \n    read*, n\n    \n    count = 0\n    temp = n\n    \n    do while (temp > 0)\n        if (mod(temp, 2) == 1) then\n            count = count + 1\n        end if\n        temp = temp / 2\n    end do\n    \n    print*, count\nend program count_set_bits\n```", "tests": [{"input": "0", "output": "0"}, {"input": "1", "output": "1"}, {"input": "10", "output": "2"}, {"input": "255", "output": "8"}, {"input": "256", "output": "1"}, {"input": "1023", "output": "10"}, {"input": "1024", "output": "1"}, {"input": "2147483647", "output": "31"}, {"input": "123456789", "output": "16"}, {"input": "1000000000", "output": "13"}, {"input": "85", "output": "4"}, {"input": "170", "output": "4"}], "raw_generation": []}
